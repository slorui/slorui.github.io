<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Slorui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/20210321171549.jpg">
    <h2 class="author">Slorui</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>65</strong><br>文章</div></a>
      <a href="/categories"><div><strong>10</strong><br>分类</div></a>
      <a href="/tags"><div><strong>15</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-计算机网络/2.物理层" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.521Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h3 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h3>
<h4 id="传输媒体"><a class="markdownIt-Anchor" href="#传输媒体"></a> 传输媒体</h4>
<p>导引型传输媒体：双绞线、同轴电缆、光纤</p>
<p>非导引型传输媒体：微波通信(2-40GHZ)、无线电波、红外线、可见光</p>
<h4 id="协议任务"><a class="markdownIt-Anchor" href="#协议任务"></a> 协议任务</h4>
<p><img src="/images/image-20210305143849954.png" alt="image-20210305143849954" /></p>
<p>物理层考虑的是怎样才能再连接计算机的传输媒体上传输数据比特流</p>
<h4 id="传输方式"><a class="markdownIt-Anchor" href="#传输方式"></a> 传输方式</h4>
<p>串行传输：数据一个比特一个比特的发   远距离传输采用串行传输</p>
<p>并行传输：多个比特同时发送，需要n条传输线路、计算机内部总线等采用并行传输</p>
<p>同步传输：发送方和接收方的时钟频率同步保证不会出现误差累积</p>
<p>​	1.外同步：收发双发加一条单独的时钟信号先</p>
<p>​	2.内同步：发送方将时钟同步信号编码到发送的数据中，如曼彻斯特编码</p>
<p>异步传输：以字节为单位独立传输，接受发从每个字节起始处对字节内比特实现同步，所以每个字节前后要加上起始位和结束位，异步是指字节之间异步</p>
<p><img src="/images/image-20210305144617911.png" alt="image-20210305144617911" /></p>
<p>单向通信：</p>
<p>双向交替通信：</p>
<p>双向同步通信：</p>
<h4 id="编码与调制"><a class="markdownIt-Anchor" href="#编码与调制"></a> 编码与调制</h4>
<p>编码：把数字/模拟信号变为数字信号</p>
<p>调制：把数字/模拟信号变为模拟信号</p>
<p>码元：代表不同离散数值的基本波形</p>
<p>信道：一般是传输媒体中的传递通道</p>
<p>计算机一般采用将数字基带信号编码调制再发送</p>
<p><img src="/images/image-20210305144944031.png" alt="image-20210305144944031" /></p>
<p>常见编码：</p>
<p><img src="/images/image-20210305145223370.png" alt="image-20210305145223370" /></p>
<p>基本调制：</p>
<p><img src="/images/image-20210305145258592.png" alt="image-20210305145258592" /></p>
<p>混合调制：使一个码元包含多个比特信息</p>
<h4 id="信道极限容量"><a class="markdownIt-Anchor" href="#信道极限容量"></a> 信道极限容量</h4>
<p>传输失真：<img src="/images/image-20210305145421893.png" alt="image-20210305145421893" /></p>
<p>乃式准则：为了避免码间干扰，传输速度是有上限的</p>
<p><img src="/images/image-20210305145602936.png" alt="image-20210305145602936" /></p>
<p>香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息速传输速率</p>
<p><img src="/images/image-20210305145656909.png" alt="image-20210305145656909" /></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82/" data-id="ckmk7003r00124kvx3nqk9mn2" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-计算机网络/1.计算机网络综述" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.492Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/">计算机网络综述</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="计算机网络综述"><a class="markdownIt-Anchor" href="#计算机网络综述"></a> 计算机网络综述</h3>
<h4 id="三种交换方式"><a class="markdownIt-Anchor" href="#三种交换方式"></a> 三种交换方式</h4>
<ol>
<li>
<p>电路交换</p>
<p>1）建立连接（分配通信资源）</p>
<p>2）通话（占用通信资源）</p>
<p>2）释放连接（归还通信资源）</p>
</li>
<li>
<p>报文交换</p>
<p>将整个报文交给下一个节点交换机</p>
</li>
<li>
<p>分组交换</p>
<p>将报文变成一个个分组 加上分组头部</p>
</li>
</ol>
<h4 id="计算机网络分类"><a class="markdownIt-Anchor" href="#计算机网络分类"></a> 计算机网络分类</h4>
<p>交换技术：电路交换网络、报文交换网络、分组交换网络</p>
<p>使用者：专用网、公用网</p>
<p>传输介质：有线网络、无线网络</p>
<p>覆盖范围：广域网WAN、城域网MAN、局域网LAN、个域网PAN</p>
<p>拓扑结构：总线型网络、星型网络、环形网络、网状型网络</p>
<h4 id="计算机性能指标"><a class="markdownIt-Anchor" href="#计算机性能指标"></a> 计算机性能指标</h4>
<p>速率：计算机再数字信道传送比特的速率、比特率</p>
<p>带宽：再模拟信号中，表示信号的频率范围；再计算机网络中，表示网络的通信线路能传输数据的能力，单位时间内从网络某一点到另一点通过的”最高数据率“</p>
<p>吞吐量：单位时间内通过某个网络的数据量</p>
<p>时延：发生时延、传播时延、处理时延</p>
<p>时延带宽积：以比特为单位的链路长度，再一个链路内的比特量</p>
<p>往返时间：RTT（Round-Trip-Time）交互一次的时间</p>
<p>利用率：信道利用率表示信道的百分之几的时间被利用；网络利用率表示全网的信道利用率的加权平均</p>
<p>丢包率：一段时间内，传输丢失的分组与总分组量的比率，包括误码、网络拥塞</p>
<h4 id="计算机网络体系结构"><a class="markdownIt-Anchor" href="#计算机网络体系结构"></a> 计算机网络体系结构</h4>
<p><img src="/images/image-20210305143317816.png" alt="image-20210305143317816" /></p>
<p><img src="/images/image-20210305143338951.png" alt="image-20210305143338951" /></p>
<p><img src="/images/image-20210305143548968.png" alt="image-20210305143548968" /></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/" data-id="ckmk7003q000x4kvx2fm02dcz" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/9.锁" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/9.%E9%94%81/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.466Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/9.%E9%94%81/">锁</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h3>
<p>InnoDB通过next-ket+可重复读解决了幻读的问题</p>
<p>InnoDB锁很高效，DML不总是产生锁对象</p>
<p>锁对象通过位图实现，内存开销小，不存在锁升级问题</p>
<h4 id="92-锁和事务"><a class="markdownIt-Anchor" href="#92-锁和事务"></a> 9.2 锁和事务</h4>
<h5 id="921-隔离性"><a class="markdownIt-Anchor" href="#921-隔离性"></a> 9.2.1 隔离性</h5>
<p>隔离性是ACID的I，锁就是实现事务的隔离性和一致性</p>
<p>隔离性要求：事务各自运行时，运行不受到其他事务的影响，提交前也看不到其他事务的结果。</p>
<p>要求用一种简单的算法或开销小的算法实现加锁技术，不能比串行化还慢</p>
<p>锁是一个串行机制，保证同一时刻只能被一个事务访问</p>
<p>MyISAM是表锁，并发没问题，并发写效率较差，如果是底部插入，有并发写入操作</p>
<p>SQLserver开始是页锁，后来支持悲观乐观并发，但是会锁升级到表锁，</p>
<h5 id="922-事务隔离级别"><a class="markdownIt-Anchor" href="#922-事务隔离级别"></a> 9.2.2 事务隔离级别</h5>
<p>脏写：两个事务先后修改了同一值，先事务进行了回滚，后事务的值没了</p>
<p>脏读：读取到了未提交的数据</p>
<p>不可重复读：两次读取的数据不同（不保证产生新的行）</p>
<h5 id="923-幻读"><a class="markdownIt-Anchor" href="#923-幻读"></a> 9.2.3 幻读</h5>
<p>幻读指统一事务下，连续两次同样的sql导致结果不同，第二次sql可能返回之前不存在的行</p>
<p>谓词锁：锁定的不是单个记录，而是一个条件</p>
<p>key-range locking算法是谓词锁的改进，锁定的是范围</p>
<p>根据范围分为next-key locking和previous-key locking</p>
<p>（-∞,W]，(W,Y],(Y,Z],(Z,+∞)<br />
范围被锁定时，阻止其他事务向这个范围内插入记录</p>
<h4 id="93-锁的类型和算法"><a class="markdownIt-Anchor" href="#93-锁的类型和算法"></a> 9.3 锁的类型和算法</h4>
<p>共享锁（S lock），允许事务读一行数据</p>
<p>排他锁（X lock），允许事务删除或更新一行数据</p>
<p>InnoDB支持多粒度锁定，允许事务在行记录或表记录同时加锁，为了多粒度锁，InnoDB支持了意向锁</p>
<p>意向锁把锁定对象分为多个层次，意味着事务希望在更细粒度上加锁</p>
<p>将上锁对象当初一棵树，要对下层节点上锁，需要先对上层对象加锁，要加x-lock，先对上层加意向锁IX，若某一部分导致等待，都需要等待粗粒度锁完成</p>
<p>InnoDB意向锁即表级别的锁，目的是为了在一个事务中揭示下一行被将被请求的锁类型</p>
<p>意向共享锁（IS）事务想获得一张表某几行的共享锁</p>
<p>意向排他锁（IX）事务想获得一张表某几行的排他锁</p>
<p><strong>意向锁的兼容性是相对表锁来的</strong></p>
<p>InnoDB是行级锁，因此意向锁不会阻塞全表扫描外的请求。</p>
<p>InnoDB支持的三种行锁</p>
<ol>
<li>record lock：记录锁</li>
<li>gap lock：间隙锁，锁定一个范围，不包含记录本身</li>
<li>next-key lock，邻键锁，间隙锁+记录锁，锁定范围+本身</li>
</ol>
<h4 id="94-锁内部实现"><a class="markdownIt-Anchor" href="#94-锁内部实现"></a> 9.4 锁内部实现</h4>
<p>页中还存有位图信息，由于位图大小可变，没有显示定义大小</p>
<p>记录是否有锁，通过位图的bit位判断</p>
<p>InnoDB支持表锁：意向锁和自增锁</p>
<p>事务信息中包含每个页的锁信息，然后多个页的锁信息链接起来</p>
<p>这种查询方式看起来不高效，但是节省了大量开销，若对每一个锁进行管理，开销会非常巨大。</p>
<p>锁查询的两种方式：</p>
<ol>
<li>根据事务：事务会维护一个内存对象，包含事务锁信息链表和指向正在等待的锁信息</li>
<li>根据记录：根据记录所在的页进行哈希查询，通过位图进行判断</li>
</ol>
<h5 id="942-锁的并发控制"><a class="markdownIt-Anchor" href="#942-锁的并发控制"></a> 9.4.2 锁的并发控制</h5>
<h4 id="95-显示锁和隐式锁"><a class="markdownIt-Anchor" href="#95-显示锁和隐式锁"></a> 9.5 显示锁和隐式锁</h4>
<p>分为explicit显示锁和implicit隐式锁</p>
<p>显示锁分为间隙显示锁（仅锁住范围）和非间隙显示锁（锁记录和记录之前的范围），可以是读锁页可以是写锁</p>
<p>隐式锁总时写锁</p>
<p>显示锁直接加锁，隐式锁是指索引记录逻辑上有写锁，内存不包含这个锁信息，没有任何内存开销，可以位于聚簇索引，也可以位于辅助索引。</p>
<p>聚簇索引插入一条记录，未提交时，就包含一个隐式锁。</p>
<p>对辅助索引进行update，产生隐式锁。并不是每次都产生隐式锁，若加锁需要等待，产生显示锁，因为后面需要被唤醒</p>
<p>由于隐式锁存在，加锁前需要把隐式锁转化成显示锁，并加信息插入全局哈希表中</p>
<h5 id="952-聚簇索引隐式锁"><a class="markdownIt-Anchor" href="#952-聚簇索引隐式锁"></a> 9.5.2 聚簇索引隐式锁</h5>
<p>每个索引记录都有一个事务id隐藏列，判断事务id读取是否为活跃事务，活跃事务有隐式锁。</p>
<h5 id="953-辅助索引记录的隐式锁"><a class="markdownIt-Anchor" href="#953-辅助索引记录的隐式锁"></a> 9.5.3 辅助索引记录的隐式锁</h5>
<p>每个辅助索引页通过page header保存一个最大事务id，当索引中任何记录被更新，更新这个最大id</p>
<ol>
<li>根据辅助索引页的最大事务id判断</li>
<li>根据聚簇索引记录进行判断</li>
</ol>
<p>当最大事务id小于活跃事务id，不包含隐式锁，之前已经提交的事务修改了该记录。若等于：</p>
<ol>
<li>存在活跃事务修改了辅助索引记录，导致最大事务id更新</li>
<li>存在事务（可能活跃（未提交），也可能完成了提交），修改了页中其他辅助索引记录，导致最大事务id更新</li>
</ol>
<p><strong>隐式锁就是会自己判断是否阻塞</strong></p>
<h4 id="96-加锁操作"><a class="markdownIt-Anchor" href="#96-加锁操作"></a> 9.6 加锁操作</h4>
<h5 id="961-加锁流程"><a class="markdownIt-Anchor" href="#961-加锁流程"></a> 9.6.1 加锁流程</h5>
<p>产生的锁对象加入到表队列的locks链表中，遍历次链表可以得出表上所有锁信息</p>
<p>对行记录加锁需要注意：</p>
<ol>
<li>是否为隐私锁，隐式锁并且没有冲突，不需要产生锁对象，否则产生对象并加入等待队列</li>
<li>锁对象是否可以重用，前提是同一个事务锁同一页记录，而且模式相同，或锁同一记录，第二次锁强度弱</li>
</ol>
<p>InnoDB锁是根据事务和页进行管理和组织的</p>
<p>哈希表只能找到记录所在页的锁对象，然后通过位图查找</p>
<h5 id="962-加锁过程"><a class="markdownIt-Anchor" href="#962-加锁过程"></a> 9.6.2 加锁过程</h5>
<ol>
<li>通过主键加锁的语句，仅对聚簇索引记录加锁</li>
<li>通过辅助索引加锁的语句，首先对辅助索引记录加锁，再对聚簇索引记录加锁</li>
<li>通过辅助索引记录加锁的语句，可能还需要对下一条记录加锁（避免幻读），若为唯一约束，则不需要，否则可能会再第二次读取时读到新插入的数据</li>
</ol>
<h4 id="97-行锁的维护"><a class="markdownIt-Anchor" href="#97-行锁的维护"></a> 9.7 行锁的维护</h4>
<p>锁对象映射到哈希桶中</p>
<h5 id="971-插入"><a class="markdownIt-Anchor" href="#971-插入"></a> 9.7.1 插入</h5>
<ol>
<li>对表加IX锁</li>
<li>根据查询模式定位记录位置</li>
<li>判断记录是否有锁，有就等待是否，没有就插入</li>
<li>若有辅助索引，还需根据2，3进行锁判断，插入后需要更新最大事务id</li>
</ol>
<p>插入记录需要定位下一条记录，这是next-key lock邻键锁算法要求，要获取下一个记录的锁，如果有锁 说明当前区域被锁定，不能插入。插入后还需要更新锁定范围</p>
<h5 id="972-更新"><a class="markdownIt-Anchor" href="#972-更新"></a> 9.7.2 更新</h5>
<p>更新（删除）前，先尝试加x（隐式）锁，若存在其他锁，事务被阻塞，等待锁释放</p>
<ol>
<li>聚簇索引加锁成功，转化为显示锁</li>
<li>辅助索引加锁成功，更新最大事务id</li>
</ol>
<p>若不能原地更新，需要把锁信息移到infinum记录上</p>
<h5 id="973-purge"><a class="markdownIt-Anchor" href="#973-purge"></a> 9.7.3 purge</h5>
<p>对标记删除的记录真正删除后，需要更新下一个记录的锁定范围。考虑时注意</p>
<h5 id="974-一致性锁定读"><a class="markdownIt-Anchor" href="#974-一致性锁定读"></a> 9.7.4 一致性锁定读</h5>
<p>默认情况，InnoDB使用一致性非锁定读。某些情况需要使用一致性锁定读保证数据的一致性，可以用lokc in share mode和for update加锁。</p>
<h5 id="975-页的分裂"><a class="markdownIt-Anchor" href="#975-页的分裂"></a> 9.7.5 页的分裂</h5>
<p>当插入导致分裂时</p>
<ol>
<li>确定分裂点记录</li>
<li>分裂点到supernum锁移到到新页，修改bitmap</li>
<li>调用函数将原superme移到新的superme（原gap锁后移）</li>
<li>将新页的第一条记录锁信息移到前页的superme（原gap锁前移）</li>
</ol>
<h5 id="976-页的合并"><a class="markdownIt-Anchor" href="#976-页的合并"></a> 9.7.6 页的合并</h5>
<ol>
<li>记录左页的最后一条记录</li>
<li>右页记录移到左页，更新锁信息</li>
<li>左页superme移到保存的左页最后一条记录</li>
<li>右页superme移到左页superme</li>
</ol>
<h4 id="98-自增锁"><a class="markdownIt-Anchor" href="#98-自增锁"></a> 9.8 自增锁</h4>
<p>自增锁插入后即释放，不会等事务提交才释放</p>
<p>自增长值并不持久化，而是每次启动时查询最大获得</p>
<p>自增锁和表的读写锁不互容</p>
<h4 id="99-死锁"><a class="markdownIt-Anchor" href="#99-死锁"></a> 9.9 死锁</h4>
<h5 id="991-死锁的概念"><a class="markdownIt-Anchor" href="#991-死锁的概念"></a> 9.9.1 死锁的概念</h5>
<p>两个或两个以上事务争夺资源的过程中互相等待的现象。</p>
<p>解决死锁的基本办法是超时回滚。</p>
<p>除了超时机制，数据库一般还采用等待图的方式进行死锁检查，保存了两种信息：</p>
<ol>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ol>
<p>若链表构造的图出现回路，就代表产生了死锁。采用深度优先搜索算法，每次加锁需要等待时，就调用判断是否会产生死锁，有就回滚事务</p>
<h5 id="992-死锁概率"><a class="markdownIt-Anchor" href="#992-死锁概率"></a> 9.9.2 死锁概率</h5>
<p>死锁概率=(n^2 * r^4)/4R   n是事务量，R是记录量</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/9.%E9%94%81/" data-id="ckmk7004h003l4kvxh2iaf5sp" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/8.索引页" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/8.%E7%B4%A2%E5%BC%95%E9%A1%B5/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.464Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/8.%E7%B4%A2%E5%BC%95%E9%A1%B5/">索引页</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引页"><a class="markdownIt-Anchor" href="#索引页"></a> 索引页</h3>
<p>InnoDB是索引组织表，聚簇索引的叶子节点存放着完整的记录，辅助索引页中存放着指向叶子节点的书签</p>
<h4 id="82-页"><a class="markdownIt-Anchor" href="#82-页"></a> 8.2 页</h4>
<p>InnoDB定义了两种页，索引页和日志页</p>
<p>由于是索引组织表，索引即数据，索引页就是数据页</p>
<h4 id="83-存储结构"><a class="markdownIt-Anchor" href="#83-存储结构"></a> 8.3 存储结构</h4>
<h5 id="831-page-header"><a class="markdownIt-Anchor" href="#831-page-header"></a> 8.3.1 Page Header</h5>
<p>page header保存页的信息，占56个字节，每个页都有两个伪记录。当删除页中记录时，page_free指向最近删除的空间，通过记录record header中的next header串联得到一个空闲链表</p>
<p>当记录申请空间时，检查page_free的空间是否够用，不够用直接去page_heap_top申请，不会遍历链表，之前的空间不会被重用。当页空间不足时，会进行页重新组织，根据主键记录排序，整理碎片空间</p>
<p>页记录是根据主键顺序排列的，顺序是逻辑上的，不是物理的（开销很大）。因此页是一个存储记录的堆，其中记录无序。</p>
<p>在传统B+树，分裂操作向左进行。InnoDB根据值判断插入放心，顺序升序插入、顺序降序插入、无序随机插入导致不同的分裂策略。</p>
<p>为了更好的顺序性存储，叶子和非叶子节点存放在不同的段对象中。</p>
<h5 id="832-page-directory"><a class="markdownIt-Anchor" href="#832-page-directory"></a> 8.3.2 page directory</h5>
<p>当进行记录查询，需要page directory。B+树只能查询到页，然后根据page directory（位于页的尾部）定位。</p>
<p>page directory由槽组成（slot），每个槽两个字节，按主键顺序逆序。</p>
<p>为了提高存储和插入效率，槽采用稀疏方式，每个槽对应了一个记录，每个槽总时包含4-8条记录。槽保证在一定范围内，当超过范围，槽会分裂产生新的槽，当低于数量，会平衡槽中记录数，可能导致删除和合并槽</p>
<h4 id="84-page-cursor"><a class="markdownIt-Anchor" href="#84-page-cursor"></a> 8.4 Page Cursor</h4>
<h5 id="841-定位记录"><a class="markdownIt-Anchor" href="#841-定位记录"></a> 8.4.1 定位记录</h5>
<p>page cursor是一个指向记录所在位置的游标，用来定位记录，通过查询模式向前或向后扫描记录</p>
<p>由于page directory是稀疏机构，因此首先通过二叉查找定位记录所在槽，然后通过二叉查找的扫描记录。</p>
<h5 id="842-插入记录"><a class="markdownIt-Anchor" href="#842-插入记录"></a> 8.4.2 插入记录</h5>
<p>插入的记录可以是物理记录，也可是逻辑记录。通常是逻辑记录，转化成物流记录。cursor指向插入记录之前的记录</p>
<p>插入记录会对页进行修改，会产生redo log。插入的redo log就是cursor定位的记录偏移量+插入的记录。为了性能，进行记录压缩。策略是找到cursor记录和当前记录的第一个不同字节，不需要对前面重复的内容记录。</p>
<p>记录插入通常将逻辑记录插入页，记录插入完成后，需要对page directory维护，看看槽是否需要平衡</p>
<h5 id="843-删除记录"><a class="markdownIt-Anchor" href="#843-删除记录"></a> 8.4.3 删除记录</h5>
<p>将记录标记为删除，然后将记录的空间放到page_header的page_free前端。需要对page directory维护</p>
<p>删除的redo log，额外的记录删除记录在页中的偏移量</p>
<h5 id="844-并发控制"><a class="markdownIt-Anchor" href="#844-并发控制"></a> 8.4.4 并发控制</h5>
<p>对于索引页的并发控制是在上层的调用中进行的，索引页不加锁</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/8.%E7%B4%A2%E5%BC%95%E9%A1%B5/" data-id="ckmk7004g003j4kvxaj30gof7" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/7.记录" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/7.%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.444Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/7.%E8%AE%B0%E5%BD%95/">记录</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="记录"><a class="markdownIt-Anchor" href="#记录"></a> 记录</h3>
<h4 id="72概述"><a class="markdownIt-Anchor" href="#72概述"></a> 7.2概述</h4>
<p>InnoDB是一种面向行的存储引擎，每个页以行记录的方式存储。基于行的好处</p>
<ol>
<li>记录放在同一页，访问一条记录需要访问的页很少</li>
<li>符合机械磁盘的访问方式</li>
<li>容易理解，数据存取就像二维表访问</li>
</ol>
<p>通常行和记录是等价的。关系数据库理论中，元组描述记录，字段描述列</p>
<p>物理记录是数据在物理存储中的格式，逻辑记录就像数组，内部放着一条条记录</p>
<p>InnoDB引擎是索引组织表(index organized table,IOT)，意味着所有用户数据都是B+树存储。叶子节点存放着每行记录，若没有主键，字段创建一个6字节的隐藏列当作主键。</p>
<p>InnoDB支持事务和MVCC，每行记录还包含了一个回滚指针以及记录事务ID的列（都是隐藏列）。回滚指针用来构造上一个版本，实现MVCC，事务ID判断当前记录其他事务是否可见，实现事务隔离和ＭＶＣＣ</p>
<h4 id="73-物理记录"><a class="markdownIt-Anchor" href="#73-物理记录"></a> 7.3 物理记录</h4>
<h5 id="731-物理记录格式"><a class="markdownIt-Anchor" href="#731-物理记录格式"></a> 7.3.1 物理记录格式</h5>
<p>物理记录由两部分组成：</p>
<ol>
<li>extra info</li>
<li>实际存储行数据</li>
</ol>
<p>extra info由col offset list和record header组成。实际存储的第一个列的位置称为original offset，物理记录总指向这个位置，不是物理记录实际开始的位置</p>
<p>开始部分col offset list是记录中每个列的偏移量，根据列的顺序逆序。每个offset list除了记录列表的长度，还记录了该列是否为null以及是否包含外部存储属性。</p>
<p>record header的内容帮助innodb读取完整的一行记录，如果需要，并转化为逻辑记录。存放了info_bits信息（记录删除标记，B+树非叶子节点最小记录标记）、记录序号，记录数量、堆中的序号、下一个记录指针等</p>
<p>InnoDB记录在页中，但是页的记录并不是按索引规则排序，页更像一个堆，，其中记录无限，但有堆中序号，记录之间通过指针逻辑串联。堆序号主要是为了实现锁</p>
<p>每个页都有两个虚拟的伪记录，所以heap no（堆号）从2开始</p>
<h5 id="732-大记录格式"><a class="markdownIt-Anchor" href="#732-大记录格式"></a> 7.3.2 大记录格式</h5>
<p>大记录是值某些记录的列不进在当前页，也在其他页（溢出页）。大记录类型有BLOB和TEXT。InnoDB不是把BLOB和TEXT都放溢出页，而是当记录总字节数大于空页的一半时，才放溢出页。对于溢出的列，在列的偏移列表中增加标记。InnoDB的处理方式，当前页值存储溢出列的127个字节，剩下20个字节存储溢出页信息</p>
<p>由于存放于off-page的字节数最大标识最大4个字节，所以BLOB最大4GB</p>
<p>大记录更新时，先把之前的伪删除，然后插入新的记录，回滚时删除新记录，恢复伪删除的数据。</p>
<h5 id="733-伪记录"><a class="markdownIt-Anchor" href="#733-伪记录"></a> 7.3.3 伪记录</h5>
<p>索引页有两个伪记录，分别伪Infimun记录和Supremum记录。用户可以把Infimun当作页中最小记录，Supremun当作最大记录。这里个记录起到了边界的作用。还可以优化锁的性能</p>
<h4 id="74-逻辑记录"><a class="markdownIt-Anchor" href="#74-逻辑记录"></a> 7.4 逻辑记录</h4>
<p>逻辑记录存放于内存，每个dtuple_struct逻辑记录包含多个dfield_struct字段，每个列的数据，大小，类型、列号等</p>
<p>大记录存放在big_rec_struct，每个大记录可能由多个big_rec_field_struct列组成</p>
<h4 id="75-记录比较"><a class="markdownIt-Anchor" href="#75-记录比较"></a> 7.5 记录比较</h4>
<p>B+树索引只能定位到所在的记录页，不能直接定位到具体的查询记录，找到页，还需通过二叉查找算法进行搜索。</p>
<p>记录比较分为逻辑记录比较和物理记录比较。通常都是通过逻辑记录和物理记录比较。对于插入，本身不存在插入的物理记录，要先构建逻辑记录。对于update，delete操作，先通过select定位，这时就转化为逻辑记录</p>
<p>InnoDB使用mtype和prtype分别代表列的类型和列的属性。通过将数据类型转化为mtype和prtype</p>
<p>通过mtype和prtype就可以进行比较</p>
<h4 id="76-行记录版本"><a class="markdownIt-Anchor" href="#76-行记录版本"></a> 7.6 行记录版本</h4>
<p>多版本是指行记录可能一时存在多个版本。记录版本号通过隐藏的事务id列表示，由于事务id自增，所以版本号id也自增</p>
<p>InnoDB通过回滚指针保存前一个版本的undo日志，通过undo日志可以构造出记录的前一个版本，从而实现统一记录的多版本。当没有事务引用这些记录版本，就可以回收这部分undo日志空间。</p>
<p>通过数据结构read_view_struct控制事务应该读取记录的哪个版本</p>
<p>read_view_struct有low_limit_id和up_limit_id保存当前的可见-不可见范围</p>
<p>在事务之前提交的事务，当前事务应当可见，当前事务之后的事务，当前事务不可见。<strong>之间的事务，能否看见取决于创建事务时，事务是否以及提交。对于为提交的事务，不可见。</strong></p>
<p>通过判断当前事务是否可以读取记录当前版本号，若不可以则构建前一个行版本。判断某个事务的版本号是否可见，从小事务开始判断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/7.%E8%AE%B0%E5%BD%95/" data-id="ckmk7004g003i4kvxb5n1eu2h" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/6.存储管理" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.429Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">存储管理</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="存储管理"><a class="markdownIt-Anchor" href="#存储管理"></a> 存储管理</h3>
<h4 id="62-物理存储"><a class="markdownIt-Anchor" href="#62-物理存储"></a> 6.2 物理存储</h4>
<p>数据库不直接使用操作系统的文件系统，而是在之上封装了一层自己对于存储设备的管理，保证数据库数据库的完整性。</p>
<p>InnoDB最小的存储单位是页，默认16KB</p>
<p>物理磁盘一个扇区512B（固态4KB），文件系统把扇区映射成块，一个块4KB。</p>
<p>为了性能，InnoDB每次申请一个区1MB，64个页，提高空间申请效率和数据存放的顺序性。</p>
<h5 id="621-页"><a class="markdownIt-Anchor" href="#621-页"></a> 6.2.1 页</h5>
<p>页是InnoDB访问的最小I/O单元，物理上连续的64页组成一个区。去除页头尾的46个字节开销，剩下空间原来存储数据。</p>
<p>每个页都有头（38字节）和尾（8字节）</p>
<p>页有页所在表空间的编号和在表空间的偏移量（a,b）。FIL_PAGE_OFFSET长度4个字节，一个表空间可存4GB*16kb 的数据</p>
<p>还有两个指针保存了前后页的偏移量</p>
<p>尾部8个字节和头部一个相同，原来判断页是否完整</p>
<h5 id="622-区"><a class="markdownIt-Anchor" href="#622-区"></a> 6.2.2 区</h5>
<p>区的大小为1MB，区的申请由（space header）空间头部信息进行管理。space header不是一个完整的页，信息保存在页（0，0）（偏移），用于区管理和分配，站112个字节</p>
<p>区分为区和碎片区。区通过链表链接，用于分配给段。碎片区是InnoDB一个特殊区，通过区保存数据前，先将数据保存在32个碎片页中。这样是为了节省空间。碎片区不属于任何段</p>
<p>每次申请区，若空间足够，申请4个，若包含碎片区，申请5个</p>
<p>每个区描述符站40个字节，追踪64个页的使用状态。</p>
<p>头部包含区id，在区链表的位置，区中页的使用情况</p>
<p>InnoDB规定一个页可放256个区描述符，而且偏移都是整数倍</p>
<p>若一个区的页含有区描述符，就称为碎片区</p>
<h5 id="623-段"><a class="markdownIt-Anchor" href="#623-段"></a> 6.2.3 段</h5>
<p>段原来保存特定的对象。表是最常见的对象。</p>
<p>InnoDB中，每个用户表最少两个段，聚簇索引的叶子节点段和非叶子节点段</p>
<p>段根据区的形式组织存储空间</p>
<p>由于有点对象很小，不需要完整的区保存数据，例如undo段，因此给每个段设计了32个碎片页，段的空间首先保存在32个碎片页中，超出后申请空间。碎片页从碎片区申请，碎片区保存在space header中，不能分配给段</p>
<p>InnoDB的设计初衷：创建表开始，随着表的增大，每次从表空间获取一个页，超过32个页后，任务数据很大，每次获取一个区。</p>
<p>segment inode用于保存段的信息，但是位置不固定。一个新的索引就有2个新的段，会有新的segment inode，索引还有一个segment header指向segment inode，每个segment header存放在索引的root页（不一定，可放在单独的页 如insertbuffer）</p>
<h5 id="624-表空间"><a class="markdownIt-Anchor" href="#624-表空间"></a> 6.2.4 表空间</h5>
<p>表空间是一个逻辑概念，由页区段组成。一个表空间可用由多个文件组成。</p>
<h4 id="63-数据结构"><a class="markdownIt-Anchor" href="#63-数据结构"></a> 6.3 数据结构</h4>
<h4 id="64-文件操作"><a class="markdownIt-Anchor" href="#64-文件操作"></a> 6.4 文件操作</h4>
<h5 id="641-异步io和同步io"><a class="markdownIt-Anchor" href="#641-异步io和同步io"></a> 6.4.1 异步I/O和同步I/O</h5>
<p>同步I/O需要阻塞等待其他完成，异步I/O可合并多次I/O。</p>
<p>数据库读操作几乎都是同步I/O，为了提高性能，还支持预读，这部分是异步I/O完成的。对于写操作，特别是脏页刷回磁盘都是异步。</p>
<h4 id="65-异步io"><a class="markdownIt-Anchor" href="#65-异步io"></a> 6.5 异步I/O</h4>
<h5 id="651-异步io数据结构"><a class="markdownIt-Anchor" href="#651-异步io数据结构"></a> 6.5.1 异步I/O数据结构</h5>
<p>由4个异步I/O线程。分别处理异步读I/O，异步写I/O，插入缓存I/O，重做日志I/O</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" data-id="ckmk7004500294kvx7u40gpn3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/5.mini-transaction" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/5.mini-transaction/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.411Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/5.mini-transaction/">mini-transaction</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="mini-transaction"><a class="markdownIt-Anchor" href="#mini-transaction"></a> mini-transaction</h3>
<h4 id="52-mini-transaction"><a class="markdownIt-Anchor" href="#52-mini-transaction"></a> 5.2 mini-transaction</h4>
<h5 id="521-基本概念"><a class="markdownIt-Anchor" href="#521-基本概念"></a> 5.2.1 基本概念</h5>
<p>mini-transaction模块，是用来实现InnoDB存储引擎物理逻辑日志的写入，通过mini-transaction保证并发事务操作下数据库异常时页数据的一致性。</p>
<p>mini-transaction仅仅用来保证页的一致性，而事务可能需要保证多个页操作数据的一致性和持久性。或者说，事务的一致性和持久性需要通过mini-transaction实现</p>
<p>当用户修改页时，通过类似的mini-transaction形式：</p>
<ol>
<li>lock专享的页</li>
<li>修改页</li>
<li>生成undo log和redo log</li>
<li>unlock页</li>
</ol>
<p>为了保证页的一致性，需要遵循：</p>
<ol>
<li>FIX Rules</li>
<li>Write-Ahead Log</li>
<li>Force-log-at-commit</li>
</ol>
<h5 id="522-fix-rules"><a class="markdownIt-Anchor" href="#522-fix-rules"></a> 5.2.2 FIX Rules</h5>
<p>当数据库访问或修改一个页时，需要持有该页的latch，保证并发的数据一致性。将这个latch称为fixing the page。获得latch后，称这个页已经fixed，</p>
<p>规则如下：</p>
<ol>
<li>修改一个页需要获得x-latch</li>
<li>访问一个页获得x-latch或s-latch</li>
<li>持有latch到修改或访问完数据</li>
</ol>
<p>如果要一次性修改多个页，需要持有多个页的latch，操作完成再释放</p>
<p>每个页struct的lock变量实现对页latch的操作。一个事务读取该页，变量就+1.当LRU替换时，必须保证为0才能替换。</p>
<p>InnoDB对FIX Rules进行了调整，若操作的页是B+树的非叶子节点，非页节点通过B+树的索引的latch维护，因此操作这些页不需要持有页的latch。</p>
<p>因此，再InnoDB判断页是否被fix的标准是lock变量是否为0</p>
<h5 id="523-write-ahead-log"><a class="markdownIt-Anchor" href="#523-write-ahead-log"></a> 5.2.3 Write-Ahead-Log</h5>
<p>WAL要求一个页操作再写入到持久存储设备时，首先必须将内存中的日志写入到持久存储</p>
<ol>
<li>每个页要有一个LSN</li>
<li>每次页的修改操作需要维护该LSN</li>
<li>当一个页刷新到持久存储设备时，要求将所有内存小于该页LSN的日志都持久化</li>
<li>当日志持久化后，将内存中的页持久化</li>
<li>页持久化时，需要fiexd保证页的一致性</li>
</ol>
<h5 id="524-force-log-at-commit"><a class="markdownIt-Anchor" href="#524-force-log-at-commit"></a> 5.2.4 Force-log-at-commit</h5>
<p>仅仅靠WAL无法保证事务的持久性，还需要force-log-at-commit</p>
<p>当事务提交时，所有mini-transaction产生的日志都必须刷新到持久存储设备</p>
<p>innodb_flush_log _at_trx_commit=0表示关闭</p>
<h4 id="53-具体实现"><a class="markdownIt-Anchor" href="#53-具体实现"></a> 5.3 具体实现</h4>
<h5 id="531-数据结构"><a class="markdownIt-Anchor" href="#531-数据结构"></a> 5.3.1 数据结构</h5>
<p>mtr_struct实现mini-transaction</p>
<h5 id="532-物理逻辑日志的实现"><a class="markdownIt-Anchor" href="#532-物理逻辑日志的实现"></a> 5.3.2 物理逻辑日志的实现</h5>
<p>InnoDB的redo log是物理逻辑的，所以需要记录每种重做日志的”逻辑“（每种重做日志的类型）</p>
<p>恢复时，根据类型对对应的也进行”逻辑“恢复</p>
<p>重做日志的开始信息由重做日志类型type、表空间ID space、页在表空间的偏移组成offset</p>
<p>type占1个字节，space和offset都通过压缩的方式存储。body体的根据日志类型不同内容不同</p>
<p>例如插入记录：记录的时插入记录的前一个记录的位置和插入记录与前一个记录的差异，所以如果一个页corrupt，无法恢复。</p>
<p>如果一个mini-transaction涉及多个页的变化，会有多个页的redo-log，会在结束时加入一个结束标志表示记录了多个页的日志</p>
<h5 id="533-mini-transaction的使用"><a class="markdownIt-Anchor" href="#533-mini-transaction的使用"></a> 5.3.3 mini-transaction的使用</h5>
<ol>
<li>每个mini-transaction拥有自己的redo log entity</li>
<li>mini-transaction持有mutex互斥量写入redo log buffer</li>
<li>redo log buffer进行缓存写，写入操作系统内存，然后写入磁盘</li>
<li>由于redo log进行fsync时已经释放了mutex，所以可以进行组提交，当一个事务进行fsync时，其他事务可以获得mutex对象，将重做日志写入重做日志缓存，下一次事务提交时，可以将多个事务的重做日志一次性写入重做日志文件</li>
</ol>
<p>当一个事务没有对页修改也要使用mini-transaction，访问数据要符合FIX Rules规则，而mini-transaction包含次功能。当提交时，仅仅对页进行unfix操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/5.mini-transaction/" data-id="ckmk7004400264kvx1n3h3k66" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/4.重做日志" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.395Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/">重做日志</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="重做日志"><a class="markdownIt-Anchor" href="#重做日志"></a> 重做日志</h3>
<h4 id="42-相关概述"><a class="markdownIt-Anchor" href="#42-相关概述"></a> 4.2 相关概述</h4>
<h5 id="421-简介"><a class="markdownIt-Anchor" href="#421-简介"></a> 4.2.1 简介</h5>
<p>redo log用来实现事务的持久性，ACID的D。由两部分组成，一是内存中的重做日志换成(redo log buffer)，易丢失，二是重做日志文件(redo log file)，持久</p>
<p>InnoDB是事务存储引擎，通过force log at commit实现日志持久化。当事务提交时，先将事务日志写入重做日志文件持久化，完成后再commit。</p>
<p>InnoDB日志由两部分组成，redo log和undo log。redo log保证事务的持久性。undo log帮助事务回滚以及MVCC功能。redo log是顺序写的，数据库允许时不需要对redo log进行读操作。undo log随机读/写。</p>
<p>为了确保每次日志都写入重做日志文件，每次将重做日志缓存写入重做日志文件后，InnoDB需要调用一个fsync操作（同步内存到磁盘）。使用fsync效率取决于磁盘性能。磁盘性能决定了事务的提交性能。</p>
<p>InnoDB允许用户设置不强制fsync，日志定时从内存写入磁盘。可以提高数据库性能。可能会丢失最后一段时间事务</p>
<p>innodb_flush_log_at_trx_commit控制策略。1强制提交，0定时提交。master thread（现在可能是其他线程）每秒进行一次redo log的fsync操作。设置未0，不符合事务的D(Durablity)特性。后续版本设为2，将redo log写入操作系统缓存，数据库宕机，操作系统不宕机，不会丢失事务。</p>
<p>MySQL还有一个二进制日志文件（bin-log），用来进行point-in-time（PIT）恢复以及主从复制。表明与redo log很像，其实本质不同。</p>
<p>redo log是InnoDB存储引擎产生，bin log是MySQL数据库上层产生，不仅仅针对InnoDB引擎。</p>
<p>两种日志内容形式不同。bin log是逻辑日志，记录对应的SQL语句（三种形式）。redo log是物理日志，记录对每个页的修改。</p>
<p>两种日志写入磁盘时间不同。bin log在事务完成后一次写入，redo log在事务进行中不断写日，表现为日志并不是随事务提交而顺序写入。</p>
<p>bin log  t1-t4-t3-t2… 一个事务一个日志（一个日志多个log event)</p>
<p>redo log t1-t2-t1-<em>t2… 一个事务多个日志，多个事务并发写入（随机写），</em> *表示提交</p>
<h5 id="422-物理逻辑日志"><a class="markdownIt-Anchor" href="#422-物理逻辑日志"></a> 4.2.2 物理逻辑日志</h5>
<p>redo log类型：</p>
<ol>
<li>物理日志：保存一个页中发生改变的字节，保存页中发生变化的字节，数据结构包括页位置，偏移，长度，旧值，新值。该日志幂等（执行多次仍一样）。产生的日志量比较大。</li>
<li>逻辑日志：记录对表的操作&lt;insert op,table name, record value&gt;，日志尺寸小，undo 操作需要对日志操作逆操作。恢复时无法保证数据一致性。插入时宕机，若还有其他索引，回滚会很困难。</li>
<li>物理逻辑日志：结合了物理日志和逻辑日志。对页是物理的，对页内操作是逻辑的。</li>
</ol>
<h5 id="423-lsn"><a class="markdownIt-Anchor" href="#423-lsn"></a> 4.2.3 LSN</h5>
<p>LSN是log sequence number缩写，代表日志序列号。占用8个字节</p>
<p>LSN单调递增，代表每个redo log的编号。初始值由LOG_START_LSN定义</p>
<p>LSN在多个对象中，含义各不相同。</p>
<p>在redo log中，表示事务写入redo log的字节量。因为redo log先写缓存，索引存在缓存的LSN和日志的LSN两部分</p>
<p>在每个页中，记录在页的头部，有个FIL_PAGE_LSN，记录页的LSN，表示该页罪和刷新时LSN大小。redo log记录的是页的日志，页的LSN判断页是否需要进行恢复。</p>
<p>检测到也通过LSN保存，表示页已经刷新到磁盘的LSN位置，重启时只需要从监测点开始恢复，检测到LSN和redo log LSN相同，不需要恢复。</p>
<h5 id="424-检查点"><a class="markdownIt-Anchor" href="#424-检查点"></a> 4.2.4 检查点</h5>
<p>InnoDB为了实现事务持久性，使用了write ahead log(WAL)策略，当事务提交时，先写入redo log，实际数据页刷到磁盘由检测到负责。</p>
<p>虽然日志已经写入到磁盘，但是buffer pool的页还没有刷到磁盘。</p>
<p>检测点就是将缓冲池的页刷新到磁盘。</p>
<p>检测点的作用就是缩短数据库宕机时到数据库恢复的时间。</p>
<p>InnoDB存在两种检测点：</p>
<ol>
<li>sharp checkpoint：将脏页全部刷到磁盘，加速宕机恢复，但是刷页时不能进行DML操作</li>
<li>fuzzy checkpoint：脏页慢慢刷到磁盘，提高了系统可用性。但是得将页按第一次修改的LSN排序</li>
</ol>
<h5 id="425-归档日志"><a class="markdownIt-Anchor" href="#425-归档日志"></a> 4.2.5 归档日志</h5>
<p>InnoDB中，redo log文件大小固定，如果3个redo log，大小1G，一共就3G。循环使用。</p>
<p>为了保存之前的redo log，设计了归档日志。</p>
<h5 id="426-恢复"><a class="markdownIt-Anchor" href="#426-恢复"></a> 4.2.6 恢复</h5>
<p>InnoDB启动时，不管是否正常改变，都试图恢复。redo log是物理日志，恢复较快。</p>
<p>InnoDB对恢复进行了优化，顺序读取和并行应用redo log。</p>
<h4 id="43-物理存储结构"><a class="markdownIt-Anchor" href="#43-物理存储结构"></a> 4.3 物理存储结构</h4>
<h5 id="431-redo-log物理结构"><a class="markdownIt-Anchor" href="#431-redo-log物理结构"></a> 4.3.1 redo log物理结构</h5>
<p>InnoDB的redo log由以下几个部分组成</p>
<ol>
<li>重做日志缓存(redo log buffer)：由innodb_log_buffer_size控制，默认1MB</li>
<li>重做日志组(redo log group)：多个组的内容一致，保证可用性，但是只能由一个组，不能启用镜像</li>
<li>每个重做日志组包含多个重做日志文件(redo log file)：可能由多个同样大小的文件组成，默认前缀ib_logfile，参数innodb_log_group_home_dir指定日志路径。innodb_log_files_in_group指定组文件数量。innodb_log_file_size指定每个redo log大小。默认5MB。总redo log大小必须小于4GB（不能等于）</li>
<li>归档重做日志文件(archive redo log)：对重做日志组1进行归档。innodb_log_archive开启归档，默认关闭，默认路径和日志路径相同，前缀ib_arch_log_</li>
</ol>
<h5 id="432-redo-log-块"><a class="markdownIt-Anchor" href="#432-redo-log-块"></a> 4.3.2 redo log 块</h5>
<p>redo log块以512字节存储，意味着redo log buffer，redo log file和archive 都是以块的方式保存的。</p>
<p>因为redo log块大小和扇区大小一致，可以保证写入的原子性，不需要doublewrite</p>
<p>redo log块除了日志本身，还有日志快头（12字节）和日志快尾（8字节）。</p>
<p>log block header包含：</p>
<p>LOG_BLOCK_HDR_NO：log buffer类似数组，这个值就是索引，4个字节，最高位判断是不是flush bit，所以最大2GB</p>
<p>LOG_BLOCK_HDR_DATA_LEN：2个字节，日志快占用的大小，写满时未0x200，表示512个字节</p>
<p>LOG_BLOCK_FIRST_REC_GROUP：2个字节，当前块第一个日志的所在偏移量</p>
<p>LOG_BLOCK_CHECK_POINT_NO：4个字节，日志块最后被写入时log_sys-&gt;next_checkpoint_no的低4个字节</p>
<p>log block tailer：只包含LOG_BLOCK_HDR_NO和头部一样</p>
<h5 id="433-重做日志组和文件"><a class="markdownIt-Anchor" href="#433-重做日志组和文件"></a> 4.3.3 重做日志组和文件</h5>
<p>log buffer刷盘规则：</p>
<ol>
<li>事务提交时</li>
<li>写入检查点值时</li>
<li>log buffer超过以使用空间的阈值时</li>
</ol>
<p>log block是通过appen追加的，一个写满写下一个，循环使用(round-robin)</p>
<p>虽然是在文件最后append，但不都是顺序写。redo log file还有2KB其他信息。保存了4个512字节大小的块</p>
<p>log file header  512字节：</p>
<p>​	log_group_id 4个字节：重做日志组号</p>
<p>​	log_file_start_lsn 8个字节：表示每个重做日志文件的第一个日志的LSN</p>
<p>checkpoint1  512字节：实际占用296字节</p>
<p>​	log_checkpoint_lsn：两个checkpoint块交替写更新checkpoint的值</p>
<p>​	log_checkpoint_offset：多个redo log file视为一个大数组，这是对应的LSN所在的offset</p>
<p>​	log_checkpoint_array：记录的是(fileno,offset)对，共32对(32*(4+4))=256字节，表示每个重做日志组的归档文件号，最多32个日志组。</p>
<p>空	512K</p>
<p>checkpoint2 512K字节</p>
<p>这些信息只在每个组的第一个文件保存，后面的文件也占有这些空间，但不存内容。</p>
<p>因为这些信息，除了log block写入，还更新这些信息。这些信息对于redo log恢复至关重要。</p>
<h4 id="44-数据结构"><a class="markdownIt-Anchor" href="#44-数据结构"></a> 4.4 数据结构</h4>
<h5 id="441-log_group_struct"><a class="markdownIt-Anchor" href="#441-log_group_struct"></a> 4.4.1 log_group_struct</h5>
<h5 id="442-log_struct"><a class="markdownIt-Anchor" href="#442-log_struct"></a> 4.4.2 log_struct</h5>
<p>表示重做日志缓存，由log_init()初始化，控制着重做日志缓存的写入，重做日志文件写入，归档重做日志的写入，在线备份等。</p>
<p>遍历buf_free表示当前重做日志缓存写入的开始位置，当大于max_buf_free时，强制进行一次重做日志文件写入。初始化时，max_buf_free设为redo log buffer的一半。</p>
<p>系统又一个控制全局的log_struct对象log_sys，实现对重做日志的操作。并发控制由数据结构log_sys中的mutex保护。保护所有的重做日志。所有重做日志的I/O是异步的，可以提前释放mutex，写入都是先写入缓存，再进行fsync，进行fsync时解法mutex保护。</p>
<h4 id="45-组提交"><a class="markdownIt-Anchor" href="#45-组提交"></a> 4.5 组提交</h4>
<p>一个事务提交一次需要进行一次fsync，为了提高性能，允许一组事务进行提交，组提交。</p>
<p>当重做日志缓冲刷新到磁盘时，先拷贝最后一个日志块，允许之后的事务写到该块，实现组提交。</p>
<p>组提交时重做日志的写入是缓存写（经过操作系统内核的page cache），没有使用O_DIRECT（之间磁盘IO）</p>
<h4 id="46-恢复"><a class="markdownIt-Anchor" href="#46-恢复"></a> 4.6 恢复</h4>
<h5 id="461-数据结构"><a class="markdownIt-Anchor" href="#461-数据结构"></a> 4.6.1 数据结构</h5>
<p>recv_sys_struct用来管理重做日志恢复。</p>
<p>其中add_hash是一个哈希表，每个bucket存放着recv_addr_t数据结构。根据(space,page_no)哈希，相同的放入一个bucket。recv_addr_t存放对应(space,page_no)页的重做日志recv_t，一个页可能由多个重做日志，通过链表将recv_t相连。每个recv_t记录了重做日志的类型，长度，开始LSN，结束LSN，已经重做日志body。body由recv_data_t定义（16KB），对大于该长度的重做日志，需要使用next指针进行链接</p>
<p>由于每个重做日志大小不同，采用动态内存分配奇数。</p>
<h5 id="462-重做日志恢复"><a class="markdownIt-Anchor" href="#462-重做日志恢复"></a> 4.6.2 重做日志恢复</h5>
<p>InnoDB启动时，不管是否正常关闭，都尝试恢复。</p>
<p>InnoDB表空间第一个页记录了数据库关闭时最后刷新页的LSN，若未正常关闭，该值和redo log的checkpoint值不同，就需要恢复</p>
<p>恢复数据时，通过小批量读取重做日志文件的log block到log_sys的buf中（64KB= 128*512k)，然后根据对应的(space,offset)插入recv_sys哈希表（addr_hash)，然后进行恢复。若保存的页过多，会强制进行恢复。</p>
<ol>
<li>分析重做日志</li>
<li>重做日志加入hash表</li>
<li>将hash表重做日志应用到页上：判断页的LSN，当大于待恢复重做日志的LSN，表示页已经写入磁盘或恢复过</li>
</ol>
<p>异步恢复：扫描一个页相邻的32个页，如果待恢复而且不在内存，就记录。然后异步读取页进行恢复。这样可以并行恢复页</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/" data-id="ckmk7004300234kvxgt9216mq" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/3.同步机制" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/3.%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.374Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/3.%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">同步机制</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="同步机制"><a class="markdownIt-Anchor" href="#同步机制"></a> 同步机制</h3>
<p>InnoDB存储引擎同步机制由sync模块实现，主要实现mutex（互斥量）以及rw-lock（读写锁）。没有使用操作系统自带的，而是自己进行了封装，并提供spin（自旋）和wait array（等待队列）设计提高性能</p>
<h4 id="31-相关文件"><a class="markdownIt-Anchor" href="#31-相关文件"></a> 3.1 相关文件</h4>
<h4 id="32-基础知识"><a class="markdownIt-Anchor" href="#32-基础知识"></a> 3.2 基础知识</h4>
<p>mutex对象是用来进行Mutual Exclusion（互斥）操作，目的是再多线程并发访问时保证共享数据的正确性。</p>
<p>linux可以提供以下数据结构进行互斥</p>
<ol>
<li>spin lock</li>
<li>semephore</li>
<li>monitor</li>
<li>sequencer</li>
</ol>
<h5 id="321-memory-model"><a class="markdownIt-Anchor" href="#321-memory-model"></a> 3.2.1 memory model</h5>
<p>内存模型决定了cpu怎么访问内存，以及并发情况下多cpu对内存的影响</p>
<p>不同内存模型的差异是在于硬件以怎么样的顺序对内存数据进行load和store</p>
<p>最简单的内存模型是（sequential memory model）顺序内存模型。所有的读写操作都是按照程序允许顺序执行的。而且要求cpu或者I/O设备读写数据操作是原子性的。开始后不能被其他内存操作中断</p>
<p>还有total storememory model和partial store memory model</p>
<h5 id="322-mutual-exclution"><a class="markdownIt-Anchor" href="#322-mutual-exclution"></a> 3.2.2 mutual exclution</h5>
<p>两个或多个cpu同时访问临界区时会产生竞争条件。为了消除这种问题，需要互斥。</p>
<h5 id="323-atomic-read-modify-write-operation"><a class="markdownIt-Anchor" href="#323-atomic-read-modify-write-operation"></a> 3.2.3 Atomic Read-Modify-Write Operation</h5>
<p>为了一次只有一个cpu访问临界区，硬件都提供了基于原子操作的read-modify-write。</p>
<p>目前cpu都支持test-and-set（TAS），从内存读取一个字节或一个word（4个字节），然后和0比较，无条件的将其再内存的值置为1.这是给原子操作，这是其他cpu或I/O设备不能访问总线。提供TAS，操作系统可以构造更高级别的同步操作，自旋锁，信号量等</p>
<p>最基本的TAS指令就是swap-atomic操作。将寄存器的值和内存的值交互，提供swap-atomic可以构造TAS操作。将寄存器值置为1，执行atomic-swap，和寄存器中的值比较</p>
<h5 id="324-spin-lock"><a class="markdownIt-Anchor" href="#324-spin-lock"></a> 3.2.4 spin lock</h5>
<p>spin-lock依赖互斥的代码应该比较少，快速释放spin-lock。</p>
<p>spin-lock执行通过先加锁后节点实现，然而乱序可能带来问题，所有要加内存屏障。</p>
<h5 id="325-死锁"><a class="markdownIt-Anchor" href="#325-死锁"></a> 3.2.5 死锁</h5>
<h4 id="33-innodb同步机制"><a class="markdownIt-Anchor" href="#33-innodb同步机制"></a> 3.3 InnoDB同步机制</h4>
<p>InnoDB同步机制：mutex，完全互斥，rw-lock，读锁允许并发读，写锁完全互斥</p>
<h5 id="331-mutex"><a class="markdownIt-Anchor" href="#331-mutex"></a> 3.3.1 mutex</h5>
<p>mutex_struct是InnoDB互斥数据结构。mutex采用TAS命令，与spin-lock不同之处</p>
<ol>
<li>当返回1时，先自旋（不用反复执行TAS，因为自旋判断值是从L1 cache或L2 cache获取，不用读内存）</li>
<li>自旋一段时间不能获得mutex，放入wait_array等待唤醒（不将进程放到等待队列，因为切换上下文需要开销）</li>
</ol>
<p>InnoDB实现自旋的目的</p>
<ol>
<li>减少内存访问</li>
<li>减少上下文切换</li>
</ol>
<p>使用mutex保护，临界区一般是1-20us，最长时间发生在索引节点的二叉查找。所以默认自旋20us</p>
<p>线程不能获得mutex时，先从wait_array分配一个cell，然后将mutex-&gt;waiter设置为1.然后再进行TAS判断。防止分配完cell时mutex线程释放资源并唤醒等待线程，由于未置1而不被唤醒，产生永远等待</p>
<p>InnoDB没有使用内存屏障解决乱序问题，而是后台一个线程定期调用换上检测是否由无限等待的mutex，有就唤醒</p>
<h4 id="332-rw-lock"><a class="markdownIt-Anchor" href="#332-rw-lock"></a> # 3.3.2 rw-lock</h4>
<p>为了提高并发，允许临界资源共享读取，</p>
<p>rw-lock使用FIFO的调度策略</p>
<p>写锁可以递归使用，读锁数据结构没有定义持有的线程id，所以无法递归</p>
<p>同mutex，不能获得锁时先自旋，然后放入wait_array队列</p>
<h5 id="333-wait-array"><a class="markdownIt-Anchor" href="#333-wait-array"></a> 3.3.3 wait array</h5>
<p>InnoDB引擎有一个全局wait array对象sync_primary_wait_array用来对等待latch线程唤醒，默认创建100个cell的等待队列，当队列1000个cell分配完，InnoDB会发生宕机。申请到cell后，等待线程会休眠，等待被唤醒</p>
<h5 id="334-死锁检测"><a class="markdownIt-Anchor" href="#334-死锁检测"></a> 3.3.4 死锁检测</h5>
<p>InnoDB实现latch同时，开启UNIV_SYNC_DEBUG模式，支持对latch加锁进行AB-BA死锁检测。InnoDB定义了每个latch的优先级，每个线程根据这个顺序加锁就不会产生AB-BA死锁</p>
<p>sync_thread_struct存储每个线程持有的latch信息，内部包含了sync_level_struct，表示每个线程持有的每个latch的level信息</p>
<p>死锁仅发生在等待的场景下，当进程放入symc_primary_wait_array的cell中时调用死锁检测函数检测死锁（使用深度优先遍历算法）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/3.%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" data-id="ckmk7004100204kvx49whc7p0" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/2.基本数据结构和算法" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.366Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/21/mysql/innodb/2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">基本数据结构和算法</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/innodb/">innodb</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本数据结构和算法"><a class="markdownIt-Anchor" href="#基本数据结构和算法"></a> 基本数据结构和算法</h3>
<h4 id="21-相关文件"><a class="markdownIt-Anchor" href="#21-相关文件"></a> 2.1 相关文件</h4>
<h4 id="22-内存管理系统"><a class="markdownIt-Anchor" href="#22-内存管理系统"></a> 2.2 内存管理系统</h4>
<p>这里的内存管理不是管理缓冲池中的页，儿是管理InnoDB引擎运行时动态生成的数据结构对象。</p>
<h5 id="221-内存管理"><a class="markdownIt-Anchor" href="#221-内存管理"></a> 2.2.1 内存管理</h5>
<p>InnoDB引擎不直接使用malloc和free管理内存</p>
<p>InnoDB引擎使用内存堆的方式来进行内存对象管理，可以一次性分配大块内存，不需要按需分配。Innodb还可以从缓冲池分配内存建立堆内存（16KB），更快的请求内存页，称为缓冲池分配，使用malloc分配内存的方法称为动态分配。</p>
<p>InnoDB存储引擎的内存管理层次结构</p>
<p><img src="/images/image-20210309140549311.png" alt="image-20210309140549311" /></p>
<p>最顶层是内存堆，存放各自用途的内存堆对象</p>
<p>下面是内存池和缓冲池。</p>
<p>通过mem_area_alloc可以从内存池建立一个内存堆或为内存堆增加一个内存块</p>
<p>通过buf_frame_alloc可以从缓冲池分配一整页大小的内存空间。</p>
<p>最下面是系统内存。</p>
<p>从操作系统分配叫动态分配，从缓冲池分配叫缓冲池分配。</p>
<p>内存堆相对于一个栈，通过不断增加内存块对象来增长空间，，只能先释放栈顶的内存块或一次性全部释放。从这个栈中可以分配更小的内存卡，也就是内存栈的功能。</p>
<p>InnoDB引擎使用数据结构mem_block_t表示内存堆中每次从操作系统或缓冲池分配的内存块。</p>
<p>本质上看，内存堆就是一系列相连接内存块。内存块头部包含mem_block_info_t存储内存块元数据信息。</p>
<p>内存堆使用第一个内存块的base字段将堆中的所有内存块根据进堆顺序链接起来。</p>
<p>Innodb定义了三种内存堆类型</p>
<ol>
<li>MEM_HEAP_DYNAMIC堆的内存调用通用内存池接口申请（阈值是8KB）</li>
<li>MEM_HEAP_BUFFER堆是内存是从缓冲池申请（阈值是缓存页框-200，默认是16KB）</li>
<li>MEM_HEAP_BTR_SEARCH是MEM_HEAP_BUFFER的子类型，仅在自适应哈希索引中使用</li>
</ol>
<p>分配内存块空间大小的三种方式：</p>
<ol>
<li>指定初始内存指针和大小，该方法无须进行内存分配</li>
<li>指定初始块大小</li>
<li>不指定初值指针和大小</li>
</ol>
<p>如果是第三者，系统分配默认大小为MEM_BLOCK_START_SIZE(64B)的内存块建堆，需要更多空间时，额外的内存块连接到链表，以后每次分配的大小是前一次的两倍，知道到达设置的阈值，之后每次分配阈值大小的内存块。</p>
<p>但调用者请求分配内存大于阈值不受限制。</p>
<h5 id="222-通用内存池"><a class="markdownIt-Anchor" href="#222-通用内存池"></a> 2.2.2 通用内存池</h5>
<p>InnoDB启动后，会实例一个mem_comm_pool对象，称为通用内存池，在InnoDB启动进行内存管理初始化时调用mem_pool_create创建。通用内存池服务于内存堆，进行小块内存分配，通常分配一些InnoDB引擎内存数据对象。</p>
<p>内存池通过free_list[64]和mem_area_struct组成内部伙伴系统解决内存碎片问题。</p>
<p>把内存池分组为64个内存区链表（就是不同链表的大小都不同）。内存块区的最小大小为mem_area_struct（内存区的结构体）对其后的两倍。</p>
<p>需要64B对象，就去free_list[6]找，找不到去free_list[7]找128然后分裂给6</p>
<h4 id="23-哈希表"><a class="markdownIt-Anchor" href="#23-哈希表"></a> 2.3 哈希表</h4>
<h5 id="231-哈希算法"><a class="markdownIt-Anchor" href="#231-哈希算法"></a> 2.3.1 哈希算法</h5>
<h5 id="232-数据结构"><a class="markdownIt-Anchor" href="#232-数据结构"></a> 2.3.2 数据结构</h5>
<p>hash_table_struct是InnoDB定义的哈希表结构，数组的存储类型是void*，因为要存储各种类型数据</p>
<p>哈希表的槽数设置位素数，可以使用函数ut_find_prime返回一个大于n的素数。</p>
<p>缓冲池的哈希表由数据结构buf_pool_struct的互斥量控制并发</p>
<p>自适应哈希索引使用的哈希表由全部的读/写锁btr_search_latch控制并发</p>
<p>InnoDB哈希表使用链地址法解决哈希冲突。但是哈希表不存链的定义</p>
<p>可以提供存储的对象自己保存的哈希链或自己创建哈希链</p>
<p>如哈希表存缓冲池的页，此时哈希链存在buf_block_t中</p>
<p>有些数据结构没有链的信息，例如自适应哈希索引，存的对象是记录，仅仅是个二进制串，对于这种对象，链的内存通过数据结构hash_table_struct的heap变量申请</p>
<p>InnoDB存储引擎，支持对各种类型对象进行查询</p>
<h4 id="24-双链表"><a class="markdownIt-Anchor" href="#24-双链表"></a> 2.4 双链表</h4>
<p>用于链接多个同类型的数据结构</p>
<p>如内存池中的内存块通过双链表管理</p>
<p>InnoDB中分为两种：组值内存对象的内存双链表和组值磁盘文件中数据的磁盘双链表</p>
<h5 id="241-内存双链表"><a class="markdownIt-Anchor" href="#241-内存双链表"></a> 2.4.1 内存双链表</h5>
<p>内存双链表是通常意义的双链表，用在InnoDB各个模块。缓冲池模块，事务处理模块，锁模块和文件系统模块等。</p>
<p>头尾指针节点LIST_BASE_NODE_T包含count（链表内节点数量）和头节点、尾节点</p>
<p>链表节点UT_LIST_NODE_T，每个被链接的对象必须是结构体而且包含链表节点对象。</p>
<h5 id="242-磁盘双链表"><a class="markdownIt-Anchor" href="#242-磁盘双链表"></a> 2.4.2 磁盘双链表</h5>
<p>磁盘双链表主要用在表空间管理模块、事务处理模块和B树模块，用于建立保存再磁盘中的数据结构的关系。由于磁盘数据库设备无法像内存通过指针随机访问，需要先把对于的磁盘块读到内存，再通过块内偏移找到所需数据</p>
<p>磁盘双链表和内存双链表的结构类似</p>
<p>基节点存放节点个数和头尾节点</p>
<p>链表节点除了前后指针，还包含fil_faddr_t，存放数据再磁盘的位置，类似内存指针。</p>
<p>FIL_ADDR_PAGE是页号的字节偏移，4个字节</p>
<p>FIL_ADDR_BYTE是页内地址偏移，站两个字节</p>
<h4 id="25-其他数据结构"><a class="markdownIt-Anchor" href="#25-其他数据结构"></a> 2.5 其他数据结构</h4>
<h5 id="251-动态数组"><a class="markdownIt-Anchor" href="#251-动态数组"></a> 2.5.1 动态数组</h5>
<p>InnoDB动态数组定义位dyn_array_t，主要用于mtr(小事务)模块，保存mtr中的锁和修改日志</p>
<p>动态数组基于块的方式扩展存储空间，每次申请DYN_ARRAY_DATA_SIZE(512B)的数组空间</p>
<p>初始化不动态分配数组空间，只初始化第一个块，不够用时分配新的内存块</p>
<h5 id="252-排序"><a class="markdownIt-Anchor" href="#252-排序"></a> 2.5.2 排序</h5>
<p>InnoDB通用的排序默认是基于合并算法进行排序，最坏复杂度log(n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" data-id="ckmk7003z001u4kvx0vthh48g" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/innodb/" rel="tag">innodb</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Blog</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/20210321171549.jpg">
    <h2 class="author">Slorui</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>65</strong><br>文章</div></a>
      <a href="/categories"><div><strong>10</strong><br>分类</div></a>
      <a href="/tags"><div><strong>15</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/slorui" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2020 - 2021 Slorui<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>