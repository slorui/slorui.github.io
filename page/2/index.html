<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">John Doe</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>32</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-mysql/innodb/7.记录" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/7.%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.444Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="记录"><a class="markdownIt-Anchor" href="#记录"></a> 记录</h3>
<h4 id="72概述"><a class="markdownIt-Anchor" href="#72概述"></a> 7.2概述</h4>
<p>InnoDB是一种面向行的存储引擎，每个页以行记录的方式存储。基于行的好处</p>
<ol>
<li>记录放在同一页，访问一条记录需要访问的页很少</li>
<li>符合机械磁盘的访问方式</li>
<li>容易理解，数据存取就像二维表访问</li>
</ol>
<p>通常行和记录是等价的。关系数据库理论中，元组描述记录，字段描述列</p>
<p>物理记录是数据在物理存储中的格式，逻辑记录就像数组，内部放着一条条记录</p>
<p>InnoDB引擎是索引组织表(index organized table,IOT)，意味着所有用户数据都是B+树存储。叶子节点存放着每行记录，若没有主键，字段创建一个6字节的隐藏列当作主键。</p>
<p>InnoDB支持事务和MVCC，每行记录还包含了一个回滚指针以及记录事务ID的列（都是隐藏列）。回滚指针用来构造上一个版本，实现MVCC，事务ID判断当前记录其他事务是否可见，实现事务隔离和ＭＶＣＣ</p>
<h4 id="73-物理记录"><a class="markdownIt-Anchor" href="#73-物理记录"></a> 7.3 物理记录</h4>
<h5 id="731-物理记录格式"><a class="markdownIt-Anchor" href="#731-物理记录格式"></a> 7.3.1 物理记录格式</h5>
<p>物理记录由两部分组成：</p>
<ol>
<li>extra info</li>
<li>实际存储行数据</li>
</ol>
<p>extra info由col offset list和record header组成。实际存储的第一个列的位置称为original offset，物理记录总指向这个位置，不是物理记录实际开始的位置</p>
<p>开始部分col offset list是记录中每个列的偏移量，根据列的顺序逆序。每个offset list除了记录列表的长度，还记录了该列是否为null以及是否包含外部存储属性。</p>
<p>record header的内容帮助innodb读取完整的一行记录，如果需要，并转化为逻辑记录。存放了info_bits信息（记录删除标记，B+树非叶子节点最小记录标记）、记录序号，记录数量、堆中的序号、下一个记录指针等</p>
<p>InnoDB记录在页中，但是页的记录并不是按索引规则排序，页更像一个堆，，其中记录无限，但有堆中序号，记录之间通过指针逻辑串联。堆序号主要是为了实现锁</p>
<p>每个页都有两个虚拟的伪记录，所以heap no（堆号）从2开始</p>
<h5 id="732-大记录格式"><a class="markdownIt-Anchor" href="#732-大记录格式"></a> 7.3.2 大记录格式</h5>
<p>大记录是值某些记录的列不进在当前页，也在其他页（溢出页）。大记录类型有BLOB和TEXT。InnoDB不是把BLOB和TEXT都放溢出页，而是当记录总字节数大于空页的一半时，才放溢出页。对于溢出的列，在列的偏移列表中增加标记。InnoDB的处理方式，当前页值存储溢出列的127个字节，剩下20个字节存储溢出页信息</p>
<p>由于存放于off-page的字节数最大标识最大4个字节，所以BLOB最大4GB</p>
<p>大记录更新时，先把之前的伪删除，然后插入新的记录，回滚时删除新记录，恢复伪删除的数据。</p>
<h5 id="733-伪记录"><a class="markdownIt-Anchor" href="#733-伪记录"></a> 7.3.3 伪记录</h5>
<p>索引页有两个伪记录，分别伪Infimun记录和Supremum记录。用户可以把Infimun当作页中最小记录，Supremun当作最大记录。这里个记录起到了边界的作用。还可以优化锁的性能</p>
<h4 id="74-逻辑记录"><a class="markdownIt-Anchor" href="#74-逻辑记录"></a> 7.4 逻辑记录</h4>
<p>逻辑记录存放于内存，每个dtuple_struct逻辑记录包含多个dfield_struct字段，每个列的数据，大小，类型、列号等</p>
<p>大记录存放在big_rec_struct，每个大记录可能由多个big_rec_field_struct列组成</p>
<h4 id="75-记录比较"><a class="markdownIt-Anchor" href="#75-记录比较"></a> 7.5 记录比较</h4>
<p>B+树索引只能定位到所在的记录页，不能直接定位到具体的查询记录，找到页，还需通过二叉查找算法进行搜索。</p>
<p>记录比较分为逻辑记录比较和物理记录比较。通常都是通过逻辑记录和物理记录比较。对于插入，本身不存在插入的物理记录，要先构建逻辑记录。对于update，delete操作，先通过select定位，这时就转化为逻辑记录</p>
<p>InnoDB使用mtype和prtype分别代表列的类型和列的属性。通过将数据类型转化为mtype和prtype</p>
<p>通过mtype和prtype就可以进行比较</p>
<h4 id="76-行记录版本"><a class="markdownIt-Anchor" href="#76-行记录版本"></a> 7.6 行记录版本</h4>
<p>多版本是指行记录可能一时存在多个版本。记录版本号通过隐藏的事务id列表示，由于事务id自增，所以版本号id也自增</p>
<p>InnoDB通过回滚指针保存前一个版本的undo日志，通过undo日志可以构造出记录的前一个版本，从而实现统一记录的多版本。当没有事务引用这些记录版本，就可以回收这部分undo日志空间。</p>
<p>通过数据结构read_view_struct控制事务应该读取记录的哪个版本</p>
<p>read_view_struct有low_limit_id和up_limit_id保存当前的可见-不可见范围</p>
<p>在事务之前提交的事务，当前事务应当可见，当前事务之后的事务，当前事务不可见。<strong>之间的事务，能否看见取决于创建事务时，事务是否以及提交。对于为提交的事务，不可见。</strong></p>
<p>通过判断当前事务是否可以读取记录当前版本号，若不可以则构建前一个行版本。判断某个事务的版本号是否可见，从小事务开始判断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/7.%E8%AE%B0%E5%BD%95/" data-id="ckmixaeh4000sasvx5qbih7q2" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/6.存储管理" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.429Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="存储管理"><a class="markdownIt-Anchor" href="#存储管理"></a> 存储管理</h3>
<h4 id="62-物理存储"><a class="markdownIt-Anchor" href="#62-物理存储"></a> 6.2 物理存储</h4>
<p>数据库不直接使用操作系统的文件系统，而是在之上封装了一层自己对于存储设备的管理，保证数据库数据库的完整性。</p>
<p>InnoDB最小的存储单位是页，默认16KB</p>
<p>物理磁盘一个扇区512B（固态4KB），文件系统把扇区映射成块，一个块4KB。</p>
<p>为了性能，InnoDB每次申请一个区1MB，64个页，提高空间申请效率和数据存放的顺序性。</p>
<h5 id="621-页"><a class="markdownIt-Anchor" href="#621-页"></a> 6.2.1 页</h5>
<p>页是InnoDB访问的最小I/O单元，物理上连续的64页组成一个区。去除页头尾的46个字节开销，剩下空间原来存储数据。</p>
<p>每个页都有头（38字节）和尾（8字节）</p>
<p>页有页所在表空间的编号和在表空间的偏移量（a,b）。FIL_PAGE_OFFSET长度4个字节，一个表空间可存4GB*16kb 的数据</p>
<p>还有两个指针保存了前后页的偏移量</p>
<p>尾部8个字节和头部一个相同，原来判断页是否完整</p>
<h5 id="622-区"><a class="markdownIt-Anchor" href="#622-区"></a> 6.2.2 区</h5>
<p>区的大小为1MB，区的申请由（space header）空间头部信息进行管理。space header不是一个完整的页，信息保存在页（0，0）（偏移），用于区管理和分配，站112个字节</p>
<p>区分为区和碎片区。区通过链表链接，用于分配给段。碎片区是InnoDB一个特殊区，通过区保存数据前，先将数据保存在32个碎片页中。这样是为了节省空间。碎片区不属于任何段</p>
<p>每次申请区，若空间足够，申请4个，若包含碎片区，申请5个</p>
<p>每个区描述符站40个字节，追踪64个页的使用状态。</p>
<p>头部包含区id，在区链表的位置，区中页的使用情况</p>
<p>InnoDB规定一个页可放256个区描述符，而且偏移都是整数倍</p>
<p>若一个区的页含有区描述符，就称为碎片区</p>
<h5 id="623-段"><a class="markdownIt-Anchor" href="#623-段"></a> 6.2.3 段</h5>
<p>段原来保存特定的对象。表是最常见的对象。</p>
<p>InnoDB中，每个用户表最少两个段，聚簇索引的叶子节点段和非叶子节点段</p>
<p>段根据区的形式组织存储空间</p>
<p>由于有点对象很小，不需要完整的区保存数据，例如undo段，因此给每个段设计了32个碎片页，段的空间首先保存在32个碎片页中，超出后申请空间。碎片页从碎片区申请，碎片区保存在space header中，不能分配给段</p>
<p>InnoDB的设计初衷：创建表开始，随着表的增大，每次从表空间获取一个页，超过32个页后，任务数据很大，每次获取一个区。</p>
<p>segment inode用于保存段的信息，但是位置不固定。一个新的索引就有2个新的段，会有新的segment inode，索引还有一个segment header指向segment inode，每个segment header存放在索引的root页（不一定，可放在单独的页 如insertbuffer）</p>
<h5 id="624-表空间"><a class="markdownIt-Anchor" href="#624-表空间"></a> 6.2.4 表空间</h5>
<p>表空间是一个逻辑概念，由页区段组成。一个表空间可用由多个文件组成。</p>
<h4 id="63-数据结构"><a class="markdownIt-Anchor" href="#63-数据结构"></a> 6.3 数据结构</h4>
<h4 id="64-文件操作"><a class="markdownIt-Anchor" href="#64-文件操作"></a> 6.4 文件操作</h4>
<h5 id="641-异步io和同步io"><a class="markdownIt-Anchor" href="#641-异步io和同步io"></a> 6.4.1 异步I/O和同步I/O</h5>
<p>同步I/O需要阻塞等待其他完成，异步I/O可合并多次I/O。</p>
<p>数据库读操作几乎都是同步I/O，为了提高性能，还支持预读，这部分是异步I/O完成的。对于写操作，特别是脏页刷回磁盘都是异步。</p>
<h4 id="65-异步io"><a class="markdownIt-Anchor" href="#65-异步io"></a> 6.5 异步I/O</h4>
<h5 id="651-异步io数据结构"><a class="markdownIt-Anchor" href="#651-异步io数据结构"></a> 6.5.1 异步I/O数据结构</h5>
<p>由4个异步I/O线程。分别处理异步读I/O，异步写I/O，插入缓存I/O，重做日志I/O</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" data-id="ckmixaeh2000pasvxfcs93e5t" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/5.mini-transaction" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/5.mini-transaction/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.411Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="mini-transaction"><a class="markdownIt-Anchor" href="#mini-transaction"></a> mini-transaction</h3>
<h4 id="52-mini-transaction"><a class="markdownIt-Anchor" href="#52-mini-transaction"></a> 5.2 mini-transaction</h4>
<h5 id="521-基本概念"><a class="markdownIt-Anchor" href="#521-基本概念"></a> 5.2.1 基本概念</h5>
<p>mini-transaction模块，是用来实现InnoDB存储引擎物理逻辑日志的写入，通过mini-transaction保证并发事务操作下数据库异常时页数据的一致性。</p>
<p>mini-transaction仅仅用来保证页的一致性，而事务可能需要保证多个页操作数据的一致性和持久性。或者说，事务的一致性和持久性需要通过mini-transaction实现</p>
<p>当用户修改页时，通过类似的mini-transaction形式：</p>
<ol>
<li>lock专享的页</li>
<li>修改页</li>
<li>生成undo log和redo log</li>
<li>unlock页</li>
</ol>
<p>为了保证页的一致性，需要遵循：</p>
<ol>
<li>FIX Rules</li>
<li>Write-Ahead Log</li>
<li>Force-log-at-commit</li>
</ol>
<h5 id="522-fix-rules"><a class="markdownIt-Anchor" href="#522-fix-rules"></a> 5.2.2 FIX Rules</h5>
<p>当数据库访问或修改一个页时，需要持有该页的latch，保证并发的数据一致性。将这个latch称为fixing the page。获得latch后，称这个页已经fixed，</p>
<p>规则如下：</p>
<ol>
<li>修改一个页需要获得x-latch</li>
<li>访问一个页获得x-latch或s-latch</li>
<li>持有latch到修改或访问完数据</li>
</ol>
<p>如果要一次性修改多个页，需要持有多个页的latch，操作完成再释放</p>
<p>每个页struct的lock变量实现对页latch的操作。一个事务读取该页，变量就+1.当LRU替换时，必须保证为0才能替换。</p>
<p>InnoDB对FIX Rules进行了调整，若操作的页是B+树的非叶子节点，非页节点通过B+树的索引的latch维护，因此操作这些页不需要持有页的latch。</p>
<p>因此，再InnoDB判断页是否被fix的标准是lock变量是否为0</p>
<h5 id="523-write-ahead-log"><a class="markdownIt-Anchor" href="#523-write-ahead-log"></a> 5.2.3 Write-Ahead-Log</h5>
<p>WAL要求一个页操作再写入到持久存储设备时，首先必须将内存中的日志写入到持久存储</p>
<ol>
<li>每个页要有一个LSN</li>
<li>每次页的修改操作需要维护该LSN</li>
<li>当一个页刷新到持久存储设备时，要求将所有内存小于该页LSN的日志都持久化</li>
<li>当日志持久化后，将内存中的页持久化</li>
<li>页持久化时，需要fiexd保证页的一致性</li>
</ol>
<h5 id="524-force-log-at-commit"><a class="markdownIt-Anchor" href="#524-force-log-at-commit"></a> 5.2.4 Force-log-at-commit</h5>
<p>仅仅靠WAL无法保证事务的持久性，还需要force-log-at-commit</p>
<p>当事务提交时，所有mini-transaction产生的日志都必须刷新到持久存储设备</p>
<p>innodb_flush_log _at_trx_commit=0表示关闭</p>
<h4 id="53-具体实现"><a class="markdownIt-Anchor" href="#53-具体实现"></a> 5.3 具体实现</h4>
<h5 id="531-数据结构"><a class="markdownIt-Anchor" href="#531-数据结构"></a> 5.3.1 数据结构</h5>
<p>mtr_struct实现mini-transaction</p>
<h5 id="532-物理逻辑日志的实现"><a class="markdownIt-Anchor" href="#532-物理逻辑日志的实现"></a> 5.3.2 物理逻辑日志的实现</h5>
<p>InnoDB的redo log是物理逻辑的，所以需要记录每种重做日志的”逻辑“（每种重做日志的类型）</p>
<p>恢复时，根据类型对对应的也进行”逻辑“恢复</p>
<p>重做日志的开始信息由重做日志类型type、表空间ID space、页在表空间的偏移组成offset</p>
<p>type占1个字节，space和offset都通过压缩的方式存储。body体的根据日志类型不同内容不同</p>
<p>例如插入记录：记录的时插入记录的前一个记录的位置和插入记录与前一个记录的差异，所以如果一个页corrupt，无法恢复。</p>
<p>如果一个mini-transaction涉及多个页的变化，会有多个页的redo-log，会在结束时加入一个结束标志表示记录了多个页的日志</p>
<h5 id="533-mini-transaction的使用"><a class="markdownIt-Anchor" href="#533-mini-transaction的使用"></a> 5.3.3 mini-transaction的使用</h5>
<ol>
<li>每个mini-transaction拥有自己的redo log entity</li>
<li>mini-transaction持有mutex互斥量写入redo log buffer</li>
<li>redo log buffer进行缓存写，写入操作系统内存，然后写入磁盘</li>
<li>由于redo log进行fsync时已经释放了mutex，所以可以进行组提交，当一个事务进行fsync时，其他事务可以获得mutex对象，将重做日志写入重做日志缓存，下一次事务提交时，可以将多个事务的重做日志一次性写入重做日志文件</li>
</ol>
<p>当一个事务没有对页修改也要使用mini-transaction，访问数据要符合FIX Rules规则，而mini-transaction包含次功能。当提交时，仅仅对页进行unfix操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/5.mini-transaction/" data-id="ckmixaeh3000qasvxhouo9dpt" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/4.重做日志" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.395Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="重做日志"><a class="markdownIt-Anchor" href="#重做日志"></a> 重做日志</h3>
<h4 id="42-相关概述"><a class="markdownIt-Anchor" href="#42-相关概述"></a> 4.2 相关概述</h4>
<h5 id="421-简介"><a class="markdownIt-Anchor" href="#421-简介"></a> 4.2.1 简介</h5>
<p>redo log用来实现事务的持久性，ACID的D。由两部分组成，一是内存中的重做日志换成(redo log buffer)，易丢失，二是重做日志文件(redo log file)，持久</p>
<p>InnoDB是事务存储引擎，通过force log at commit实现日志持久化。当事务提交时，先将事务日志写入重做日志文件持久化，完成后再commit。</p>
<p>InnoDB日志由两部分组成，redo log和undo log。redo log保证事务的持久性。undo log帮助事务回滚以及MVCC功能。redo log是顺序写的，数据库允许时不需要对redo log进行读操作。undo log随机读/写。</p>
<p>为了确保每次日志都写入重做日志文件，每次将重做日志缓存写入重做日志文件后，InnoDB需要调用一个fsync操作（同步内存到磁盘）。使用fsync效率取决于磁盘性能。磁盘性能决定了事务的提交性能。</p>
<p>InnoDB允许用户设置不强制fsync，日志定时从内存写入磁盘。可以提高数据库性能。可能会丢失最后一段时间事务</p>
<p>innodb_flush_log_at_trx_commit控制策略。1强制提交，0定时提交。master thread（现在可能是其他线程）每秒进行一次redo log的fsync操作。设置未0，不符合事务的D(Durablity)特性。后续版本设为2，将redo log写入操作系统缓存，数据库宕机，操作系统不宕机，不会丢失事务。</p>
<p>MySQL还有一个二进制日志文件（bin-log），用来进行point-in-time（PIT）恢复以及主从复制。表明与redo log很像，其实本质不同。</p>
<p>redo log是InnoDB存储引擎产生，bin log是MySQL数据库上层产生，不仅仅针对InnoDB引擎。</p>
<p>两种日志内容形式不同。bin log是逻辑日志，记录对应的SQL语句（三种形式）。redo log是物理日志，记录对每个页的修改。</p>
<p>两种日志写入磁盘时间不同。bin log在事务完成后一次写入，redo log在事务进行中不断写日，表现为日志并不是随事务提交而顺序写入。</p>
<p>bin log  t1-t4-t3-t2… 一个事务一个日志（一个日志多个log event)</p>
<p>redo log t1-t2-t1-<em>t2… 一个事务多个日志，多个事务并发写入（随机写），</em> *表示提交</p>
<h5 id="422-物理逻辑日志"><a class="markdownIt-Anchor" href="#422-物理逻辑日志"></a> 4.2.2 物理逻辑日志</h5>
<p>redo log类型：</p>
<ol>
<li>物理日志：保存一个页中发生改变的字节，保存页中发生变化的字节，数据结构包括页位置，偏移，长度，旧值，新值。该日志幂等（执行多次仍一样）。产生的日志量比较大。</li>
<li>逻辑日志：记录对表的操作&lt;insert op,table name, record value&gt;，日志尺寸小，undo 操作需要对日志操作逆操作。恢复时无法保证数据一致性。插入时宕机，若还有其他索引，回滚会很困难。</li>
<li>物理逻辑日志：结合了物理日志和逻辑日志。对页是物理的，对页内操作是逻辑的。</li>
</ol>
<h5 id="423-lsn"><a class="markdownIt-Anchor" href="#423-lsn"></a> 4.2.3 LSN</h5>
<p>LSN是log sequence number缩写，代表日志序列号。占用8个字节</p>
<p>LSN单调递增，代表每个redo log的编号。初始值由LOG_START_LSN定义</p>
<p>LSN在多个对象中，含义各不相同。</p>
<p>在redo log中，表示事务写入redo log的字节量。因为redo log先写缓存，索引存在缓存的LSN和日志的LSN两部分</p>
<p>在每个页中，记录在页的头部，有个FIL_PAGE_LSN，记录页的LSN，表示该页罪和刷新时LSN大小。redo log记录的是页的日志，页的LSN判断页是否需要进行恢复。</p>
<p>检测到也通过LSN保存，表示页已经刷新到磁盘的LSN位置，重启时只需要从监测点开始恢复，检测到LSN和redo log LSN相同，不需要恢复。</p>
<h5 id="424-检查点"><a class="markdownIt-Anchor" href="#424-检查点"></a> 4.2.4 检查点</h5>
<p>InnoDB为了实现事务持久性，使用了write ahead log(WAL)策略，当事务提交时，先写入redo log，实际数据页刷到磁盘由检测到负责。</p>
<p>虽然日志已经写入到磁盘，但是buffer pool的页还没有刷到磁盘。</p>
<p>检测点就是将缓冲池的页刷新到磁盘。</p>
<p>检测点的作用就是缩短数据库宕机时到数据库恢复的时间。</p>
<p>InnoDB存在两种检测点：</p>
<ol>
<li>sharp checkpoint：将脏页全部刷到磁盘，加速宕机恢复，但是刷页时不能进行DML操作</li>
<li>fuzzy checkpoint：脏页慢慢刷到磁盘，提高了系统可用性。但是得将页按第一次修改的LSN排序</li>
</ol>
<h5 id="425-归档日志"><a class="markdownIt-Anchor" href="#425-归档日志"></a> 4.2.5 归档日志</h5>
<p>InnoDB中，redo log文件大小固定，如果3个redo log，大小1G，一共就3G。循环使用。</p>
<p>为了保存之前的redo log，设计了归档日志。</p>
<h5 id="426-恢复"><a class="markdownIt-Anchor" href="#426-恢复"></a> 4.2.6 恢复</h5>
<p>InnoDB启动时，不管是否正常改变，都试图恢复。redo log是物理日志，恢复较快。</p>
<p>InnoDB对恢复进行了优化，顺序读取和并行应用redo log。</p>
<h4 id="43-物理存储结构"><a class="markdownIt-Anchor" href="#43-物理存储结构"></a> 4.3 物理存储结构</h4>
<h5 id="431-redo-log物理结构"><a class="markdownIt-Anchor" href="#431-redo-log物理结构"></a> 4.3.1 redo log物理结构</h5>
<p>InnoDB的redo log由以下几个部分组成</p>
<ol>
<li>重做日志缓存(redo log buffer)：由innodb_log_buffer_size控制，默认1MB</li>
<li>重做日志组(redo log group)：多个组的内容一致，保证可用性，但是只能由一个组，不能启用镜像</li>
<li>每个重做日志组包含多个重做日志文件(redo log file)：可能由多个同样大小的文件组成，默认前缀ib_logfile，参数innodb_log_group_home_dir指定日志路径。innodb_log_files_in_group指定组文件数量。innodb_log_file_size指定每个redo log大小。默认5MB。总redo log大小必须小于4GB（不能等于）</li>
<li>归档重做日志文件(archive redo log)：对重做日志组1进行归档。innodb_log_archive开启归档，默认关闭，默认路径和日志路径相同，前缀ib_arch_log_</li>
</ol>
<h5 id="432-redo-log-块"><a class="markdownIt-Anchor" href="#432-redo-log-块"></a> 4.3.2 redo log 块</h5>
<p>redo log块以512字节存储，意味着redo log buffer，redo log file和archive 都是以块的方式保存的。</p>
<p>因为redo log块大小和扇区大小一致，可以保证写入的原子性，不需要doublewrite</p>
<p>redo log块除了日志本身，还有日志快头（12字节）和日志快尾（8字节）。</p>
<p>log block header包含：</p>
<p>LOG_BLOCK_HDR_NO：log buffer类似数组，这个值就是索引，4个字节，最高位判断是不是flush bit，所以最大2GB</p>
<p>LOG_BLOCK_HDR_DATA_LEN：2个字节，日志快占用的大小，写满时未0x200，表示512个字节</p>
<p>LOG_BLOCK_FIRST_REC_GROUP：2个字节，当前块第一个日志的所在偏移量</p>
<p>LOG_BLOCK_CHECK_POINT_NO：4个字节，日志块最后被写入时log_sys-&gt;next_checkpoint_no的低4个字节</p>
<p>log block tailer：只包含LOG_BLOCK_HDR_NO和头部一样</p>
<h5 id="433-重做日志组和文件"><a class="markdownIt-Anchor" href="#433-重做日志组和文件"></a> 4.3.3 重做日志组和文件</h5>
<p>log buffer刷盘规则：</p>
<ol>
<li>事务提交时</li>
<li>写入检查点值时</li>
<li>log buffer超过以使用空间的阈值时</li>
</ol>
<p>log block是通过appen追加的，一个写满写下一个，循环使用(round-robin)</p>
<p>虽然是在文件最后append，但不都是顺序写。redo log file还有2KB其他信息。保存了4个512字节大小的块</p>
<p>log file header  512字节：</p>
<p>​	log_group_id 4个字节：重做日志组号</p>
<p>​	log_file_start_lsn 8个字节：表示每个重做日志文件的第一个日志的LSN</p>
<p>checkpoint1  512字节：实际占用296字节</p>
<p>​	log_checkpoint_lsn：两个checkpoint块交替写更新checkpoint的值</p>
<p>​	log_checkpoint_offset：多个redo log file视为一个大数组，这是对应的LSN所在的offset</p>
<p>​	log_checkpoint_array：记录的是(fileno,offset)对，共32对(32*(4+4))=256字节，表示每个重做日志组的归档文件号，最多32个日志组。</p>
<p>空	512K</p>
<p>checkpoint2 512K字节</p>
<p>这些信息只在每个组的第一个文件保存，后面的文件也占有这些空间，但不存内容。</p>
<p>因为这些信息，除了log block写入，还更新这些信息。这些信息对于redo log恢复至关重要。</p>
<h4 id="44-数据结构"><a class="markdownIt-Anchor" href="#44-数据结构"></a> 4.4 数据结构</h4>
<h5 id="441-log_group_struct"><a class="markdownIt-Anchor" href="#441-log_group_struct"></a> 4.4.1 log_group_struct</h5>
<h5 id="442-log_struct"><a class="markdownIt-Anchor" href="#442-log_struct"></a> 4.4.2 log_struct</h5>
<p>表示重做日志缓存，由log_init()初始化，控制着重做日志缓存的写入，重做日志文件写入，归档重做日志的写入，在线备份等。</p>
<p>遍历buf_free表示当前重做日志缓存写入的开始位置，当大于max_buf_free时，强制进行一次重做日志文件写入。初始化时，max_buf_free设为redo log buffer的一半。</p>
<p>系统又一个控制全局的log_struct对象log_sys，实现对重做日志的操作。并发控制由数据结构log_sys中的mutex保护。保护所有的重做日志。所有重做日志的I/O是异步的，可以提前释放mutex，写入都是先写入缓存，再进行fsync，进行fsync时解法mutex保护。</p>
<h4 id="45-组提交"><a class="markdownIt-Anchor" href="#45-组提交"></a> 4.5 组提交</h4>
<p>一个事务提交一次需要进行一次fsync，为了提高性能，允许一组事务进行提交，组提交。</p>
<p>当重做日志缓冲刷新到磁盘时，先拷贝最后一个日志块，允许之后的事务写到该块，实现组提交。</p>
<p>组提交时重做日志的写入是缓存写（经过操作系统内核的page cache），没有使用O_DIRECT（之间磁盘IO）</p>
<h4 id="46-恢复"><a class="markdownIt-Anchor" href="#46-恢复"></a> 4.6 恢复</h4>
<h5 id="461-数据结构"><a class="markdownIt-Anchor" href="#461-数据结构"></a> 4.6.1 数据结构</h5>
<p>recv_sys_struct用来管理重做日志恢复。</p>
<p>其中add_hash是一个哈希表，每个bucket存放着recv_addr_t数据结构。根据(space,page_no)哈希，相同的放入一个bucket。recv_addr_t存放对应(space,page_no)页的重做日志recv_t，一个页可能由多个重做日志，通过链表将recv_t相连。每个recv_t记录了重做日志的类型，长度，开始LSN，结束LSN，已经重做日志body。body由recv_data_t定义（16KB），对大于该长度的重做日志，需要使用next指针进行链接</p>
<p>由于每个重做日志大小不同，采用动态内存分配奇数。</p>
<h5 id="462-重做日志恢复"><a class="markdownIt-Anchor" href="#462-重做日志恢复"></a> 4.6.2 重做日志恢复</h5>
<p>InnoDB启动时，不管是否正常关闭，都尝试恢复。</p>
<p>InnoDB表空间第一个页记录了数据库关闭时最后刷新页的LSN，若未正常关闭，该值和redo log的checkpoint值不同，就需要恢复</p>
<p>恢复数据时，通过小批量读取重做日志文件的log block到log_sys的buf中（64KB= 128*512k)，然后根据对应的(space,offset)插入recv_sys哈希表（addr_hash)，然后进行恢复。若保存的页过多，会强制进行恢复。</p>
<ol>
<li>分析重做日志</li>
<li>重做日志加入hash表</li>
<li>将hash表重做日志应用到页上：判断页的LSN，当大于待恢复重做日志的LSN，表示页已经写入磁盘或恢复过</li>
</ol>
<p>异步恢复：扫描一个页相邻的32个页，如果待恢复而且不在内存，就记录。然后异步读取页进行恢复。这样可以并行恢复页</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/" data-id="ckmixaeh2000oasvx73yrcyko" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/3.同步机制" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/3.%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.374Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="同步机制"><a class="markdownIt-Anchor" href="#同步机制"></a> 同步机制</h3>
<p>InnoDB存储引擎同步机制由sync模块实现，主要实现mutex（互斥量）以及rw-lock（读写锁）。没有使用操作系统自带的，而是自己进行了封装，并提供spin（自旋）和wait array（等待队列）设计提高性能</p>
<h4 id="31-相关文件"><a class="markdownIt-Anchor" href="#31-相关文件"></a> 3.1 相关文件</h4>
<h4 id="32-基础知识"><a class="markdownIt-Anchor" href="#32-基础知识"></a> 3.2 基础知识</h4>
<p>mutex对象是用来进行Mutual Exclusion（互斥）操作，目的是再多线程并发访问时保证共享数据的正确性。</p>
<p>linux可以提供以下数据结构进行互斥</p>
<ol>
<li>spin lock</li>
<li>semephore</li>
<li>monitor</li>
<li>sequencer</li>
</ol>
<h5 id="321-memory-model"><a class="markdownIt-Anchor" href="#321-memory-model"></a> 3.2.1 memory model</h5>
<p>内存模型决定了cpu怎么访问内存，以及并发情况下多cpu对内存的影响</p>
<p>不同内存模型的差异是在于硬件以怎么样的顺序对内存数据进行load和store</p>
<p>最简单的内存模型是（sequential memory model）顺序内存模型。所有的读写操作都是按照程序允许顺序执行的。而且要求cpu或者I/O设备读写数据操作是原子性的。开始后不能被其他内存操作中断</p>
<p>还有total storememory model和partial store memory model</p>
<h5 id="322-mutual-exclution"><a class="markdownIt-Anchor" href="#322-mutual-exclution"></a> 3.2.2 mutual exclution</h5>
<p>两个或多个cpu同时访问临界区时会产生竞争条件。为了消除这种问题，需要互斥。</p>
<h5 id="323-atomic-read-modify-write-operation"><a class="markdownIt-Anchor" href="#323-atomic-read-modify-write-operation"></a> 3.2.3 Atomic Read-Modify-Write Operation</h5>
<p>为了一次只有一个cpu访问临界区，硬件都提供了基于原子操作的read-modify-write。</p>
<p>目前cpu都支持test-and-set（TAS），从内存读取一个字节或一个word（4个字节），然后和0比较，无条件的将其再内存的值置为1.这是给原子操作，这是其他cpu或I/O设备不能访问总线。提供TAS，操作系统可以构造更高级别的同步操作，自旋锁，信号量等</p>
<p>最基本的TAS指令就是swap-atomic操作。将寄存器的值和内存的值交互，提供swap-atomic可以构造TAS操作。将寄存器值置为1，执行atomic-swap，和寄存器中的值比较</p>
<h5 id="324-spin-lock"><a class="markdownIt-Anchor" href="#324-spin-lock"></a> 3.2.4 spin lock</h5>
<p>spin-lock依赖互斥的代码应该比较少，快速释放spin-lock。</p>
<p>spin-lock执行通过先加锁后节点实现，然而乱序可能带来问题，所有要加内存屏障。</p>
<h5 id="325-死锁"><a class="markdownIt-Anchor" href="#325-死锁"></a> 3.2.5 死锁</h5>
<h4 id="33-innodb同步机制"><a class="markdownIt-Anchor" href="#33-innodb同步机制"></a> 3.3 InnoDB同步机制</h4>
<p>InnoDB同步机制：mutex，完全互斥，rw-lock，读锁允许并发读，写锁完全互斥</p>
<h5 id="331-mutex"><a class="markdownIt-Anchor" href="#331-mutex"></a> 3.3.1 mutex</h5>
<p>mutex_struct是InnoDB互斥数据结构。mutex采用TAS命令，与spin-lock不同之处</p>
<ol>
<li>当返回1时，先自旋（不用反复执行TAS，因为自旋判断值是从L1 cache或L2 cache获取，不用读内存）</li>
<li>自旋一段时间不能获得mutex，放入wait_array等待唤醒（不将进程放到等待队列，因为切换上下文需要开销）</li>
</ol>
<p>InnoDB实现自旋的目的</p>
<ol>
<li>减少内存访问</li>
<li>减少上下文切换</li>
</ol>
<p>使用mutex保护，临界区一般是1-20us，最长时间发生在索引节点的二叉查找。所以默认自旋20us</p>
<p>线程不能获得mutex时，先从wait_array分配一个cell，然后将mutex-&gt;waiter设置为1.然后再进行TAS判断。防止分配完cell时mutex线程释放资源并唤醒等待线程，由于未置1而不被唤醒，产生永远等待</p>
<p>InnoDB没有使用内存屏障解决乱序问题，而是后台一个线程定期调用换上检测是否由无限等待的mutex，有就唤醒</p>
<h4 id="332-rw-lock"><a class="markdownIt-Anchor" href="#332-rw-lock"></a> # 3.3.2 rw-lock</h4>
<p>为了提高并发，允许临界资源共享读取，</p>
<p>rw-lock使用FIFO的调度策略</p>
<p>写锁可以递归使用，读锁数据结构没有定义持有的线程id，所以无法递归</p>
<p>同mutex，不能获得锁时先自旋，然后放入wait_array队列</p>
<h5 id="333-wait-array"><a class="markdownIt-Anchor" href="#333-wait-array"></a> 3.3.3 wait array</h5>
<p>InnoDB引擎有一个全局wait array对象sync_primary_wait_array用来对等待latch线程唤醒，默认创建100个cell的等待队列，当队列1000个cell分配完，InnoDB会发生宕机。申请到cell后，等待线程会休眠，等待被唤醒</p>
<h5 id="334-死锁检测"><a class="markdownIt-Anchor" href="#334-死锁检测"></a> 3.3.4 死锁检测</h5>
<p>InnoDB实现latch同时，开启UNIV_SYNC_DEBUG模式，支持对latch加锁进行AB-BA死锁检测。InnoDB定义了每个latch的优先级，每个线程根据这个顺序加锁就不会产生AB-BA死锁</p>
<p>sync_thread_struct存储每个线程持有的latch信息，内部包含了sync_level_struct，表示每个线程持有的每个latch的level信息</p>
<p>死锁仅发生在等待的场景下，当进程放入symc_primary_wait_array的cell中时调用死锁检测函数检测死锁（使用深度优先遍历算法）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/3.%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" data-id="ckmixaeh1000nasvxd52eeqmk" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/2.基本数据结构和算法" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.366Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本数据结构和算法"><a class="markdownIt-Anchor" href="#基本数据结构和算法"></a> 基本数据结构和算法</h3>
<h4 id="21-相关文件"><a class="markdownIt-Anchor" href="#21-相关文件"></a> 2.1 相关文件</h4>
<h4 id="22-内存管理系统"><a class="markdownIt-Anchor" href="#22-内存管理系统"></a> 2.2 内存管理系统</h4>
<p>这里的内存管理不是管理缓冲池中的页，儿是管理InnoDB引擎运行时动态生成的数据结构对象。</p>
<h5 id="221-内存管理"><a class="markdownIt-Anchor" href="#221-内存管理"></a> 2.2.1 内存管理</h5>
<p>InnoDB引擎不直接使用malloc和free管理内存</p>
<p>InnoDB引擎使用内存堆的方式来进行内存对象管理，可以一次性分配大块内存，不需要按需分配。Innodb还可以从缓冲池分配内存建立堆内存（16KB），更快的请求内存页，称为缓冲池分配，使用malloc分配内存的方法称为动态分配。</p>
<p>InnoDB存储引擎的内存管理层次结构</p>
<p><img src="C:%5CUsers%5Cslorui%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210309140549311.png" alt="image-20210309140549311" /></p>
<p>最顶层是内存堆，存放各自用途的内存堆对象</p>
<p>下面是内存池和缓冲池。</p>
<p>通过mem_area_alloc可以从内存池建立一个内存堆或为内存堆增加一个内存块</p>
<p>通过buf_frame_alloc可以从缓冲池分配一整页大小的内存空间。</p>
<p>最下面是系统内存。</p>
<p>从操作系统分配叫动态分配，从缓冲池分配叫缓冲池分配。</p>
<p>内存堆相对于一个栈，通过不断增加内存块对象来增长空间，，只能先释放栈顶的内存块或一次性全部释放。从这个栈中可以分配更小的内存卡，也就是内存栈的功能。</p>
<p>InnoDB引擎使用数据结构mem_block_t表示内存堆中每次从操作系统或缓冲池分配的内存块。</p>
<p>本质上看，内存堆就是一系列相连接内存块。内存块头部包含mem_block_info_t存储内存块元数据信息。</p>
<p>内存堆使用第一个内存块的base字段将堆中的所有内存块根据进堆顺序链接起来。</p>
<p>Innodb定义了三种内存堆类型</p>
<ol>
<li>MEM_HEAP_DYNAMIC堆的内存调用通用内存池接口申请（阈值是8KB）</li>
<li>MEM_HEAP_BUFFER堆是内存是从缓冲池申请（阈值是缓存页框-200，默认是16KB）</li>
<li>MEM_HEAP_BTR_SEARCH是MEM_HEAP_BUFFER的子类型，仅在自适应哈希索引中使用</li>
</ol>
<p>分配内存块空间大小的三种方式：</p>
<ol>
<li>指定初始内存指针和大小，该方法无须进行内存分配</li>
<li>指定初始块大小</li>
<li>不指定初值指针和大小</li>
</ol>
<p>如果是第三者，系统分配默认大小为MEM_BLOCK_START_SIZE(64B)的内存块建堆，需要更多空间时，额外的内存块连接到链表，以后每次分配的大小是前一次的两倍，知道到达设置的阈值，之后每次分配阈值大小的内存块。</p>
<p>但调用者请求分配内存大于阈值不受限制。</p>
<h5 id="222-通用内存池"><a class="markdownIt-Anchor" href="#222-通用内存池"></a> 2.2.2 通用内存池</h5>
<p>InnoDB启动后，会实例一个mem_comm_pool对象，称为通用内存池，在InnoDB启动进行内存管理初始化时调用mem_pool_create创建。通用内存池服务于内存堆，进行小块内存分配，通常分配一些InnoDB引擎内存数据对象。</p>
<p>内存池通过free_list[64]和mem_area_struct组成内部伙伴系统解决内存碎片问题。</p>
<p>把内存池分组为64个内存区链表（就是不同链表的大小都不同）。内存块区的最小大小为mem_area_struct（内存区的结构体）对其后的两倍。</p>
<p>需要64B对象，就去free_list[6]找，找不到去free_list[7]找128然后分裂给6</p>
<h4 id="23-哈希表"><a class="markdownIt-Anchor" href="#23-哈希表"></a> 2.3 哈希表</h4>
<h5 id="231-哈希算法"><a class="markdownIt-Anchor" href="#231-哈希算法"></a> 2.3.1 哈希算法</h5>
<h5 id="232-数据结构"><a class="markdownIt-Anchor" href="#232-数据结构"></a> 2.3.2 数据结构</h5>
<p>hash_table_struct是InnoDB定义的哈希表结构，数组的存储类型是void*，因为要存储各种类型数据</p>
<p>哈希表的槽数设置位素数，可以使用函数ut_find_prime返回一个大于n的素数。</p>
<p>缓冲池的哈希表由数据结构buf_pool_struct的互斥量控制并发</p>
<p>自适应哈希索引使用的哈希表由全部的读/写锁btr_search_latch控制并发</p>
<p>InnoDB哈希表使用链地址法解决哈希冲突。但是哈希表不存链的定义</p>
<p>可以提供存储的对象自己保存的哈希链或自己创建哈希链</p>
<p>如哈希表存缓冲池的页，此时哈希链存在buf_block_t中</p>
<p>有些数据结构没有链的信息，例如自适应哈希索引，存的对象是记录，仅仅是个二进制串，对于这种对象，链的内存通过数据结构hash_table_struct的heap变量申请</p>
<p>InnoDB存储引擎，支持对各种类型对象进行查询</p>
<h4 id="24-双链表"><a class="markdownIt-Anchor" href="#24-双链表"></a> 2.4 双链表</h4>
<p>用于链接多个同类型的数据结构</p>
<p>如内存池中的内存块通过双链表管理</p>
<p>InnoDB中分为两种：组值内存对象的内存双链表和组值磁盘文件中数据的磁盘双链表</p>
<h5 id="241-内存双链表"><a class="markdownIt-Anchor" href="#241-内存双链表"></a> 2.4.1 内存双链表</h5>
<p>内存双链表是通常意义的双链表，用在InnoDB各个模块。缓冲池模块，事务处理模块，锁模块和文件系统模块等。</p>
<p>头尾指针节点LIST_BASE_NODE_T包含count（链表内节点数量）和头节点、尾节点</p>
<p>链表节点UT_LIST_NODE_T，每个被链接的对象必须是结构体而且包含链表节点对象。</p>
<h5 id="242-磁盘双链表"><a class="markdownIt-Anchor" href="#242-磁盘双链表"></a> 2.4.2 磁盘双链表</h5>
<p>磁盘双链表主要用在表空间管理模块、事务处理模块和B树模块，用于建立保存再磁盘中的数据结构的关系。由于磁盘数据库设备无法像内存通过指针随机访问，需要先把对于的磁盘块读到内存，再通过块内偏移找到所需数据</p>
<p>磁盘双链表和内存双链表的结构类似</p>
<p>基节点存放节点个数和头尾节点</p>
<p>链表节点除了前后指针，还包含fil_faddr_t，存放数据再磁盘的位置，类似内存指针。</p>
<p>FIL_ADDR_PAGE是页号的字节偏移，4个字节</p>
<p>FIL_ADDR_BYTE是页内地址偏移，站两个字节</p>
<h4 id="25-其他数据结构"><a class="markdownIt-Anchor" href="#25-其他数据结构"></a> 2.5 其他数据结构</h4>
<h5 id="251-动态数组"><a class="markdownIt-Anchor" href="#251-动态数组"></a> 2.5.1 动态数组</h5>
<p>InnoDB动态数组定义位dyn_array_t，主要用于mtr(小事务)模块，保存mtr中的锁和修改日志</p>
<p>动态数组基于块的方式扩展存储空间，每次申请DYN_ARRAY_DATA_SIZE(512B)的数组空间</p>
<p>初始化不动态分配数组空间，只初始化第一个块，不够用时分配新的内存块</p>
<h5 id="252-排序"><a class="markdownIt-Anchor" href="#252-排序"></a> 2.5.2 排序</h5>
<p>InnoDB通用的排序默认是基于合并算法进行排序，最坏复杂度log(n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" data-id="ckmixaeh0000masvx54e06h81" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/13.事务处理" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/13.%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.357Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事务处理"><a class="markdownIt-Anchor" href="#事务处理"></a> 事务处理</h3>
<h4 id="132-事务"><a class="markdownIt-Anchor" href="#132-事务"></a> 13.2 事务</h4>
<h5 id="1321-概述"><a class="markdownIt-Anchor" href="#1321-概述"></a> 13.2.1 概述</h5>
<p>actomicity：原子性，一起成功或一起失败。事务是不可分割的工作单位。</p>
<p>consistency：一致性：事务将数据库从一种一致状态变为另一种一致状态，事务开始前和结束后数据库的完整性约束没有被破坏</p>
<p>isolation：隔离性，事务之间不可见。当前数据库系统都提供了一种粒度锁策略，只锁实体对象的子集</p>
<p>durable：持久性，事务一旦提交，结果就是永久性的。</p>
<h5 id="1322-分类"><a class="markdownIt-Anchor" href="#1322-分类"></a> 13.2.2 分类</h5>
<ol>
<li>扁平事务</li>
<li>带有保持点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ol>
<h5 id="1323-隔离级别"><a class="markdownIt-Anchor" href="#1323-隔离级别"></a> 13.2.3 隔离级别</h5>
<ol>
<li>read uncommitted：读未提交。产生脏读</li>
<li>read committed：读提交，产生不可重复读</li>
<li>repeatable read：可重复读，产生幻读</li>
<li>serializable：序列化。</li>
</ol>
<p>InnoDB通过repeatable read和Next-Key Lock（间隙锁）避免了幻读</p>
<h4 id="133-事务系统结构"><a class="markdownIt-Anchor" href="#133-事务系统结构"></a> 13.3 事务系统结构</h4>
<h5 id="1331-事务系统段"><a class="markdownIt-Anchor" href="#1331-事务系统段"></a> 13.3.1 事务系统段</h5>
<p>InnoDB有专门的物理位置保存事务的相关信息，称为事务系统段，包含：</p>
<ol>
<li>事务相关信息</li>
<li>回滚段segment header信息</li>
<li>MySQL bin log日志文件位置</li>
<li>doublewrite段信息</li>
</ol>
<h4 id="134-doubewrite段"><a class="markdownIt-Anchor" href="#134-doubewrite段"></a> 13.4 doubewrite段</h4>
<p>InnoDB为了避免partial write问题，使用doublewrite刷新策略，页刷新到磁盘时，批量的刷新到达doublewrite，然后再刷新到对应的位置。</p>
<p>doublewrite段的segment header保存在事务系统段TRX_SYS_DOUBLEWRITE_FSEG之后。doublewrite是顺序写入的，段的分配是分配碎片页，所以doublewrite开始时，先申请32个碎片页，然后申请2MB空间。</p>
<p>doublewrite内存也有2MB空间。进行写入时，先把页复制到doublewrite buffer，double write buffer就行一个2MB的数组，每个元素大小16K，变量first_free表示下一个可以写入的位置，first_free等于128B表示写满</p>
<h4 id="135-undo-日志"><a class="markdownIt-Anchor" href="#135-undo-日志"></a> 13.5 undo 日志</h4>
<h5 id="1351-简介"><a class="markdownIt-Anchor" href="#1351-简介"></a> 13.5.1 简介</h5>
<p>undo日志有两个作用，一个是实现事务的原子性，事务通过undo log回滚。另一个是用来实现一致性非锁定读。</p>
<p>一致性非锁定读指InnoDB通过MVCC读取数据库的数据。如果读的数据正在更新，不会等待写锁释放，会去读一个快照数据</p>
<p>也有undo log是用来回滚事务的，本来就存在，所以快照本身没有开销</p>
<h5 id="1352-结构"><a class="markdownIt-Anchor" href="#1352-结构"></a> 13.5.2 结构</h5>
<p>undo有点特别。其存放是通过两个对象完成的：回滚段和undo段，这里个段的segment header都保存在自己的段内</p>
<p>回滚段保存undo 段segment herder所在页的位置，可以保存1024个undo段信息。</p>
<p>事务系统段一共可以保存156个回滚段，理论最高并发256*1024个事务，mysql仅仅用了1个回滚段，所以只有1024个事务（InnoDB1.1开始支持128个回滚段）</p>
<h5 id="1353-回滚段"><a class="markdownIt-Anchor" href="#1353-回滚段"></a> 13.5.3 回滚段</h5>
<p>回滚段有一个链表，按事务提交顺序逆序存放undo日志，当进行purge时，先读取尾端undo日志，判断是否可以回收该空间</p>
<h5 id="1354-undo段"><a class="markdownIt-Anchor" href="#1354-undo段"></a> 13.5.4 undo段</h5>
<p>undo段才真正存储undo日志。每个回滚段保存了1024个undo段，undo段内存储undo页</p>
<ol>
<li>undo log page header：18个字节</li>
<li>undo log segment haeder（仅仅在undo段的第一个undo页中），30个字节</li>
<li>undo 日志</li>
</ol>
<p>一个undo段有多个undo页，第一个undo页多了segment header，其他每个页有页header和日志</p>
<p>创建undo日志的任何对象时，要先写redo log。恢复时要根据redo恢复undo，然后判断事务回滚还是提交</p>
<p>InnoDB引擎允许一个页存放多个不同事务的undo日志，提交事务时，把undo放入链表，判断页的可用空间是否大于3/4，就可重用。</p>
<p>由于undo log的history链表是以页链接的，而undo页放着不同事务的日志，所以purge需要是涉及磁盘离散读取，比较慢</p>
<p>若undo段中undo页数量大于1，则不可重用</p>
<h4 id="136-undo-记录"><a class="markdownIt-Anchor" href="#136-undo-记录"></a> 13.6 undo 记录</h4>
<h4 id="1361-存储结构"><a class="markdownIt-Anchor" href="#1361-存储结构"></a> 13.6.1 存储结构</h4>
<p>undo日志以逻辑的方式进行存储，意味着回滚只能将数据库逻辑的恢复到原来的样子。数据被逻辑的恢复，但数据结构和页本身可能不太相同。不能将一个页回滚到事务开始的样子，因为有页的并发修改</p>
<p>每个undo log有两部分组成：</p>
<ol>
<li>undo log header：保存每个日志通用信息</li>
<li>undo log record：分为insert undo log和update undo log，除了insert其他DML都是update</li>
</ol>
<p>事务发生DML操作时，分配一个undo log header。insert和update不能放在同一个undo 段，若每个事务都有insert和update，最多就是1024/2=512个事务</p>
<p>insert undo log插入后其他事务看不到，所以事务提交后就能删除</p>
<p>update undo log需要purge线程清理</p>
<p>根据产生的undo log就可把数据恢复到之前的版本，若之前的版本记录undo log未清理，可构建新的版本。（MVCC非锁定读的实现过程）</p>
<h5 id="1362-insert-undo-log-record"><a class="markdownIt-Anchor" href="#1362-insert-undo-log-record"></a> 13.6.2 insert undo log record</h5>
<p>insert undo log包含了日志类型，事务的id，事务第几个操作产生的undo log，操作的表，主键信息等</p>
<p>insert操作不一定会产生insert undo log，可能产生update undo log，例如删除一个主键1的记录然后再插入主键1的记录，当插入记录完全相同，就变成了update undo log</p>
<h5 id="1363-update-undo-log-record"><a class="markdownIt-Anchor" href="#1363-update-undo-log-record"></a> 13.6.3 update undo log record</h5>
<p>改undo要提高mvcc操作，事务结束不能立即删除，放入回滚段的history链表头部，等待purge线程处理</p>
<p>除了事务信息，主要存储以下三部分信息：</p>
<ol>
<li>记录的主键值列表</li>
<li>发生更新的列</li>
<li>索引列：若更新了索引列，方便再purge时删掉对应的辅助索引</li>
</ol>
<p>主键值链表固定存在，后面的两部分信息取决于是否产生这些修改</p>
<p>当一个undo页放不下时，会把之前的删掉，然后再undo段创建新的页然后写入，同时改页不可重用</p>
<h4 id="137-purge"><a class="markdownIt-Anchor" href="#137-purge"></a> 13.7 purge</h4>
<h5 id="1371-清理操作"><a class="markdownIt-Anchor" href="#1371-清理操作"></a> 13.7.1 清理操作</h5>
<p>purge的2个清理操作：</p>
<ol>
<li>清理记录。删除已经标记delete mark的记录或其他相关辅助索引记录</li>
<li>清理undo log。若undo 页中所有undo记录都被删除，清理undo 段</li>
</ol>
<p>只有没有任何事务通过undo日志进行MVCC，才可用清理undo log</p>
<p>innodb会按照事务提交顺序把undo log放到回滚段的history链表（提交顺序逆序）</p>
<p>由于提交导致的事务无序，所有purge要进行大量随机读，purge 再master thread线程完成。忙碌时，秒10秒回收20个undo页。</p>
<h5 id="1372-实现原理"><a class="markdownIt-Anchor" href="#1372-实现原理"></a> 13.7.2 实现原理</h5>
<p>InnoDB中，有一个全局对象保存当前purge的位置与信息。</p>
<p>purge对象持有表的写锁，而drop table需要持有读锁，这就保证了purge时不会删除表</p>
<p>purge对象的latch保证删除的正确性，开始purge时，要先持有写锁，然后看那个undo log可被清理。当MVCC时，需要持有读锁。保证了读的时候不会被删除</p>
<p>可以pruge undo时，处理主键或辅助索引，同时删除对应的undo。如果undo清空，，删除history链表。</p>
<p>当清理到20个页或清空完毕，退出。</p>
<h4 id="138-rollback"><a class="markdownIt-Anchor" href="#138-rollback"></a> 13.8 rollback</h4>
<h4 id="1381-回滚指针"><a class="markdownIt-Anchor" href="#1381-回滚指针"></a> 13.8.1 回滚指针</h4>
<p>InnoDB存储引擎包含roll_ptr（回滚指针）7个字节的隐藏列。指向当前记录的undo log。</p>
<p>因为innodb最多128个undo段（最高位是undo log 的类型），每个页偏移4个字节，页内偏移2个字节，七个字节刚刚好</p>
<h5 id="1382-回滚操作"><a class="markdownIt-Anchor" href="#1382-回滚操作"></a> 13.8.2 回滚操作</h5>
<p>用户态回滚：将事务进行的所有操作都撤销</p>
<p>内核态回滚：存储引擎内部发起的回滚，仅回滚事务最近的一个sql（发生违反约束等，事务未结束，此时之前的数据仍存在，需要用户显示回滚）或回滚整个事务（死锁、事务超时）</p>
<p>回滚时：</p>
<ol>
<li>取得undo log</li>
<li>根据undo log回滚</li>
</ol>
<h4 id="139-commit"><a class="markdownIt-Anchor" href="#139-commit"></a> 13.9 commit</h4>
<p>回滚操作也需要进行事务提交，释放事务持有的资源：undo段，锁，read view等。为了满足持久性，必须刷新redo log，确保写入外存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/13.%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" data-id="ckmixaegz000kasvxe8hwhwt3" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/12.缓冲池" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/12.%E7%BC%93%E5%86%B2%E6%B1%A0/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.338Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h3>
<p>磁盘数据库一般通过缓冲池弥补cpu和磁盘速度的差距</p>
<h4 id="122-概述"><a class="markdownIt-Anchor" href="#122-概述"></a> 12.2 概述</h4>
<h5 id="1221-缓冲池"><a class="markdownIt-Anchor" href="#1221-缓冲池"></a> 12.2.1 缓冲池</h5>
<p>页从缓冲池刷新会磁盘不是再每次更新后，而是以一定的频率，通过checkpoint机制刷回磁盘</p>
<p>缓冲池中缓存的数据页类型又：索引页，数据页，undo页，插入缓存，自适应哈希索引，锁信息。</p>
<p>前四个会持久化，自适应哈希和锁信息不会持久化，生命周期再存储引擎运行过程中</p>
<p>每个事务锁信息再trx_struct对象的lock_heap变量分配，当空间大于8KB，就从缓冲池分配，这种情况可能出现大事务</p>
<h5 id="1222-lru-free和flush链表"><a class="markdownIt-Anchor" href="#1222-lru-free和flush链表"></a> 12.2.2 LRU、Free和Flush链表</h5>
<p>缓冲池是一块很大的内存区（16KB的倍数）。</p>
<p>缓冲池有一个free链表，保存至未使用的内存页空间，当free链表页被使用完毕。当再申请空间时，需要LRU算法淘汰使用的页</p>
<p>数据库的缓冲池都是通过LRU算法管理的。InnoDB对LRU进行了优化，LRU加入了midpoint位置，读取的新页放到midpoint位置，位于3/8处，这样可以避免大量数据扫描时把常用页刷出链表</p>
<p>自适应哈希和锁信息的页申请空间后并不放入LRU链表</p>
<p>缓冲池中的页不仅需要被读取，还需要修改，修改的页肯定发生在LRU链表中，当LRU链表页被修改后，被称为脏页。数据库通过checkpoint机制刷回磁盘。flush链表的页就是脏页。脏页既存在于flush，也存在于LRU。</p>
<p>缓冲池mutex已经拆分位缓冲池mutex，flush链表mutex，哈希表re-latch，buf_block_t的mutex</p>
<h4 id="123-缓冲池的管理"><a class="markdownIt-Anchor" href="#123-缓冲池的管理"></a> 12.3 缓冲池的管理</h4>
<h5 id="1231-lru算法"><a class="markdownIt-Anchor" href="#1231-lru算法"></a> 12.3.1 LRU算法</h5>
<h5 id="1232-lru链表维护"><a class="markdownIt-Anchor" href="#1232-lru链表维护"></a> 12.3.2 LRU链表维护</h5>
<h5 id="1233-页的分配"><a class="markdownIt-Anchor" href="#1233-页的分配"></a> 12.3.3 页的分配</h5>
<p>当free_list被分配完毕，需要从LRU链表尾部替换。条件：</p>
<ol>
<li>页不是脏的</li>
<li>页没有其他线程使用</li>
</ol>
<p>如果页是脏的，需要先刷新到磁盘。页如果被其他线程使用，页不能立即替换出去</p>
<p>找到可替换页后，需要对页进行free操作，从缓冲池的哈希表删除页，若有自适应哈希，还删除自适应哈希</p>
<h4 id="124-页的读取"><a class="markdownIt-Anchor" href="#124-页的读取"></a> 12.4 页的读取</h4>
<h5 id="1241-物理读取"><a class="markdownIt-Anchor" href="#1241-物理读取"></a> 12.4.1 物理读取</h5>
<p>InnoDB启动时，缓冲池时空的，所有页都在free链表，数据库读写都再缓冲池完成，这时主要是从外村读取页到缓冲池</p>
<h5 id="1242-随机预读"><a class="markdownIt-Anchor" href="#1242-随机预读"></a> 12.4.2 随机预读</h5>
<p>随机预读指判断某个区域的页是否大多已经被访问，并且是否位热点页，若满足条件，则认位该区域的页都可能被访问，提前进行读取。预读根据某区域内的space和offset顺序读取，可以提高性能。</p>
<p>预取区域根据每32个页进行管理。预读要求32个页的大部分被访问过，默认阈值是9，而且活跃</p>
<h5 id="1243-线性预读"><a class="markdownIt-Anchor" href="#1243-线性预读"></a> 12.4.3 线性预读</h5>
<p>线性预读判断页的访问是否是顺序的，InnoDB就会出发线性预读，连续读取之后的页</p>
<p>读取一个页，若页是某个区域的边界，本区域的部分页被顺序访问，出发线性预读，顺序读取32个页</p>
<h5 id="1244-逻辑读取"><a class="markdownIt-Anchor" href="#1244-逻辑读取"></a> 12.4.4 逻辑读取</h5>
<p>逻辑读取是从缓冲池访问指定的页。若页已经再缓冲池，通过缓冲池的哈希表进行搜索。页需要加锁访问，然而对非叶子节点的访问是通过所有本身的latch保护的，不需要对页加锁</p>
<h4 id="125-页的刷新"><a class="markdownIt-Anchor" href="#125-页的刷新"></a> 12.5 页的刷新</h4>
<h5 id="1251-检查点"><a class="markdownIt-Anchor" href="#1251-检查点"></a> 12.5.1 检查点</h5>
<p>检查点技术解决了以下问题：</p>
<ol>
<li>缩短数据库恢复时间</li>
<li>缓冲池不够时，脏页刷回磁盘</li>
<li>redo log不可用，刷新脏页</li>
</ol>
<p>InnoDB存在两种检查点：</p>
<ol>
<li>Sharp Checkpoint：数据库关闭时所有脏页刷会磁盘</li>
<li>Fuzzy Checkpoint：部分脏页刷回磁盘</li>
</ol>
<p>Fuzzy Checkpoint发生的情况：</p>
<ol>
<li>
<p>Master Thread Checkpoint，每秒和每十秒（异步，不会阻塞用户线程）</p>
</li>
<li>
<p>Asycn/Sync Flush Checkpoint，redo log不可用，强制刷新，此时脏页从flush_list选取</p>
<p>当checkpoint&lt;0.75*redo log size（最大） 不刷藏</p>
<p>当0.75<em>redo log size &lt; checkpoint&lt;0.9</em>redo log size 触发Async刷新，从flush list刷足够的脏页回磁盘满足&lt;0.75</p>
</li>
</ol>
<h5 id="1252-部分写"><a class="markdownIt-Anchor" href="#1252-部分写"></a> 12.5.2 部分写</h5>
<p>页的刷新会遇到部分写，对一个页只写入了一部分内容，如写入4KB（操作系统只保证512B写入原子）</p>
<p>为了避免部分写，实现了doublewrite，页刷新到磁盘时首先写入doublewrite，然后写入磁盘。发生部分写时，通过doublewrite中的页恢复。doublewrite存在于内存表空间，大小位2MB，一次最多进行128页刷新</p>
<h5 id="1253-刷新的实现"><a class="markdownIt-Anchor" href="#1253-刷新的实现"></a> 12.5.3 刷新的实现</h5>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/12.%E7%BC%93%E5%86%B2%E6%B1%A0/" data-id="ckmixaegy000jasvxgm986a1y" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/11.insert buffer" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/11.insert%20buffer/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.324Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="insert-buffer"><a class="markdownIt-Anchor" href="#insert-buffer"></a> insert buffer</h3>
<h4 id="112-基本概念"><a class="markdownIt-Anchor" href="#112-基本概念"></a> 11.2 基本概念</h4>
<p>Insert buffer是InnoDB存储引擎独有的，可以大幅提高数据库非唯一约束的辅助索引的插入性能</p>
<p>随机插入会收到辅助索引的影响，因此大批量导入数据时，一半不建议先建立辅助索引，当导入完成后再建立辅助索引</p>
<p>Insert buffer：插入时首先判断插入的辅助索引叶子是否再缓冲池中，若再直接插入，否则插入的记录放在insert buffer中，根据一些算法将记录通过后台线程慢慢的merge到辅助索引页。好处是：</p>
<ol>
<li>减少磁盘离散读取</li>
<li>将多次插入合并为一次操作</li>
</ol>
<p>insert buffer只能缓存非唯一约束索引，唯一索引需要判断插入记录是否唯一，还需要读取辅助索引页。</p>
<h4 id="113-架构实现"><a class="markdownIt-Anchor" href="#113-架构实现"></a> 11.3 架构实现</h4>
<h5 id="1131-存储结构"><a class="markdownIt-Anchor" href="#1131-存储结构"></a> 11.3.1 存储结构</h5>
<p>Insert Buffer也是一棵B+树。键值为待插入辅助索引页的page_no。Insert Buffer默认最多占缓冲池的一半。</p>
<p>Insert Buffer会把插入的辅助索引记录缓存起来，但是必须保证缓存的记录不会引起页的分裂。当缓存记录过多，会主动读取辅助索引页，将记录合并回页，然后进行悲观插入操作。InnoDB 存在也该Insert Buffer bitmap页，用来追踪每个辅助索引页的剩余空间，当小于某阈值（512B）就必须主动合并。</p>
<p>以为一个Insert Buffer bitmap只能追踪一个辅助索引页2KB的空间，所以Insert Buffer 最多缓存2KB。</p>
<p>B+树索引由两个段，root页保存了非叶子节点段和页节点段的段头信息</p>
<p>insert buffer只有一个数据段，存放所有非叶子节点和页节点。</p>
<h5 id="1132-逻辑控制"><a class="markdownIt-Anchor" href="#1132-逻辑控制"></a> 11.3.2 逻辑控制</h5>
<p>insert buffer的合并分为主动和被动。</p>
<p>主动是指master thread定期随机将记录合并到辅助索引页。每秒有处理能力就合并五个，每十秒必定处理五个</p>
<p>被动是指用户主动发起辅助索引页的读取操作，回被动的将记录合并到辅助索引页。由于辅助索引页已经读取到缓冲池，后续插入不会记录到insert buffer</p>
<h4 id="114-相关数据结构"><a class="markdownIt-Anchor" href="#114-相关数据结构"></a> 11.4 相关数据结构</h4>
<h4 id="115-死锁"><a class="markdownIt-Anchor" href="#115-死锁"></a> 11.5 死锁</h4>
<h5 id="1151-latch顺序"><a class="markdownIt-Anchor" href="#1151-latch顺序"></a> 11.5.1 latch顺序</h5>
<p>当辅助索引页读取到缓存而这时发生merge，可能回引起insert buffer索引树的收缩，所以需要持有insert buffer索引树内存对象x-latch</p>
<p>还有就是异步I/O，当所有线程都在读取辅助索引页，而辅助索引页又需要合并，没有线程能读insert buffer树，就出现了死锁</p>
<p>为了方式死锁，InnoDB页的逻辑页分为三个层次</p>
<ol>
<li>非insert buffer页</li>
<li>除了insert buffer bitmap页的insert buffer页</li>
<li>insert buffer bitmap页</li>
</ol>
<p>insert buffer有独立的文件空间管理，insert buffer页的段都保存再root页的free list链表中，当进行insert buffer 树的扩展或收缩时，先判断freelist是否有足够的页，这就使得fsp模块与insert buffer模块分离，避免了死锁</p>
<h5 id="1152-并发控制"><a class="markdownIt-Anchor" href="#1152-并发控制"></a> 11.5.2 并发控制</h5>
<p>引入了四个insert buffer latch</p>
<h5 id="1153-异步io线程"><a class="markdownIt-Anchor" href="#1153-异步io线程"></a> 11.5.3 异步I/O线程</h5>
<p>由于读取辅助索引页发起了异步I/O，因此当Insert buffer合并时，又发起了异步I/O，会陷入等待状态</p>
<p>将insert buffer的异步I/O放入一个单独的I/O线程</p>
<h4 id="116-维护"><a class="markdownIt-Anchor" href="#116-维护"></a> 11.6 维护</h4>
<h5 id="1161-记录合并"><a class="markdownIt-Anchor" href="#1161-记录合并"></a> 11.6.1 记录合并</h5>
<p>无论是主动还是被动，顺序都是先读取辅助索引页，再读取insert buffer页</p>
<h5 id="1162-空间收缩"><a class="markdownIt-Anchor" href="#1162-空间收缩"></a> 11.6.2 空间收缩</h5>
<p>当删除insert buffer中的记录时，这些页会从树删除，放入free list头部，然后通过收缩将页放回insert buffer段的空间</p>
<p>为了避免每次回收占用大量空间，每次最多回收4个页</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/11.insert%20buffer/" data-id="ckmixaeh0000lasvx73ng5wy9" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-mysql/innodb/10.B+树索引" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/mysql/innodb/10.B+%E6%A0%91%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:53:05.288Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="b树索引"><a class="markdownIt-Anchor" href="#b树索引"></a> B+树索引</h3>
<h4 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B+树</h4>
<h5 id="1011-概述"><a class="markdownIt-Anchor" href="#1011-概述"></a> 10.1.1 概述</h5>
<p>B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，所有记录节点都按键值大小顺序存放在同一层叶子节点，各节点指针相连</p>
<h5 id="1012-插入"><a class="markdownIt-Anchor" href="#1012-插入"></a> 10.1.2 插入</h5>
<p>三种情况：</p>
<ol>
<li>叶子，索引都没满：直接插入</li>
<li>叶子满，索引没满：插入，分裂叶子</li>
<li>叶子满，索引满：插入，分裂叶子和索引</li>
</ol>
<p>B+树主要作用于磁盘，因此要减少分裂操作，B+树也提高了旋转功能</p>
<p>旋转发生在页子满时，其左右兄弟节点没满，将记录转移到左右兄弟节点上</p>
<h5 id="1013-删除"><a class="markdownIt-Anchor" href="#1013-删除"></a> 10.1.3 删除</h5>
<p>B+树使用填充因子控制树的删除变化，50%是填充因子的最小值</p>
<p>三种情况</p>
<ol>
<li>叶子和索引都不小于填充因子：直接删除，如果该节点还是索引页的节点，用右节点代替</li>
<li>叶子节点小于填充因子：合并叶子节点和兄弟节点，更新索引</li>
<li>都小于填充因子：合并叶子节点和兄弟，更新索引，合并索引和兄弟节点</li>
</ol>
<h4 id="102-b树索引"><a class="markdownIt-Anchor" href="#102-b树索引"></a> 10.2 B+树索引</h4>
<h5 id="1021-索引的特点"><a class="markdownIt-Anchor" href="#1021-索引的特点"></a> 10.2.1 索引的特点</h5>
<h5 id="1022-聚簇索引"><a class="markdownIt-Anchor" href="#1022-聚簇索引"></a> 10.2.2 聚簇索引</h5>
<p>聚簇索引是将表的主键作为键值构建的B+树</p>
<p>聚簇索引的记录是按键值顺序存放的，是逻辑顺序，不是物理顺序，开销太大</p>
<h5 id="1023-辅助索引"><a class="markdownIt-Anchor" href="#1023-辅助索引"></a> 10.2.3 辅助索引</h5>
<p>辅助索引称为二级索引或非聚簇索引。辅助索引的叶子节点保存&lt;键值，记录地址&gt;。聚簇索引页中保存的是下层页的地址，辅助索引页子节点保存记录的地址。记录的地址一般有</p>
<ol>
<li>记录的物理地址，页号，槽号：偏移量（MyISAM，没有聚簇索引，记录放在堆表中，主键索引和非主键索引没区别，只是唯一并且非空）</li>
<li>记录的主键值（InnoDB）</li>
</ol>
<p>因为辅助索引叶子节点存放主键，所有还需要通过一次聚簇索引查询，回表</p>
<p>辅助索引非叶子节点存放记录&lt;键值、主键值、地址&gt;，辅助索引的非叶子节点也存在主键值信息，辅助索引节点不保存因此列（事务id和undo指针）</p>
<h5 id="1024-填充因子"><a class="markdownIt-Anchor" href="#1024-填充因子"></a> 10.2.4 填充因子</h5>
<p>因为小于0.5就会合并，索引填充因子大于0.5，顺序插入可能达到0.9以上，一般为0.69</p>
<h4 id="103-innodb的b树实现"><a class="markdownIt-Anchor" href="#103-innodb的b树实现"></a> 10.3 InnoDB的B+树实现</h4>
<h5 id="1032-相关latch"><a class="markdownIt-Anchor" href="#1032-相关latch"></a> 10.3.2 相关latch</h5>
<p>B+树索引的并发控制通过两部分latch进行，每个页都有一个读写锁，每个索引树对象中还有一个读写锁，可以理解为非叶子节点的读写锁（或B+树索引的读/写锁）</p>
<h5 id="1033-整理"><a class="markdownIt-Anchor" href="#1033-整理"></a> 10.3.3 整理</h5>
<p>InnoDB中页是一个无序堆，记录之间通过record header的next header串联。删除记录时，记录所占用的空间放到链表page-free，下次再分配空间时查找第一个空间是否满足，满足则分配记录空间，否则从page-heap-top分配</p>
<p>对页进行DML操作时，若页空间不足，先进行整理操作，空间仍不够，进行分裂</p>
<p>对页整理时，先加x-latch，该操作仅记录重做日志的类型。</p>
<h5 id="1034-分裂"><a class="markdownIt-Anchor" href="#1034-分裂"></a> 10.3.4 分裂</h5>
<p>InnoDB索引存在磁盘，所以对B+树索引进行了优化，不再将中间记录作为分裂点，而是根据插入情况判断，有效利用磁盘空间</p>
<p>分裂时，先判断拆入模式（递增，递减，无序）</p>
<p>步骤：</p>
<ol>
<li>确定分裂点记录</li>
<li>从索引数据段分配一个新页，加上x-latch</li>
<li>确定需要移动页中开始的第一个记录和移动到的记录</li>
<li>更新上层节点记录</li>
<li>将记录移到新页</li>
<li>待插入记录插入页</li>
<li>若插入失败，页重新组织，再次进行插入</li>
<li>若上述失败，再次去1进行分裂</li>
</ol>
<h5 id="1035-合并"><a class="markdownIt-Anchor" href="#1035-合并"></a> 10.3.5 合并</h5>
<p>更新或删除后，页的填充率可能小于0.5，这是会进行合并，若左右节点没有空间，不进行合并</p>
<p>先对内存对象和待合并页加锁，然后合并页判断左兄弟，左兄弟存在，就合并左兄弟，及时空间不足，也不合并右兄弟</p>
<h4 id="104-查找"><a class="markdownIt-Anchor" href="#104-查找"></a> 10.4 查找</h4>
<h5 id="1041-mode"><a class="markdownIt-Anchor" href="#1041-mode"></a> 10.4.1 mode</h5>
<p>查询可能为小于，小于等于，大于，大于等于等，但再非叶子节点查询只能是小于或小于等于。对于插入，只能是小于等于，找到插入记录的前一条记录。</p>
<p>若对主键或唯一索引进行查询，使用大于等于，因为InnoDB支持MVCC，即使进行了唯一约束，但页内也可能存在多个键值相同记录（例如被标记为删除的记录）。</p>
<p>当再一个页查询不到，查到supernm时，会继续去下一个页查询</p>
<h5 id="1042-latch-mode"><a class="markdownIt-Anchor" href="#1042-latch-mode"></a> 10.4.2 latch mode</h5>
<p>InnoDB总是先对索引内存对象加上s-latch，然后进行页操作，或insert、update、delete不会导致非叶子节点变化（分裂、合并、树的高度变化）立即释放内存对象s-latch（乐观方式）、否则，换成x-latch（悲观方式）</p>
<h5 id="1043-cursor"><a class="markdownIt-Anchor" href="#1043-cursor"></a> 10.4.3 cursor</h5>
<h4 id="105-dml操作"><a class="markdownIt-Anchor" href="#105-dml操作"></a> 10.5 DML操作</h4>
<h5 id="1051-插入"><a class="markdownIt-Anchor" href="#1051-插入"></a> 10.5.1 插入</h5>
<p>InnoDB插入分为两部分，首先调用乐观插入，如果发生分裂等，调用悲观插入</p>
<p>乐观插入时，发现不能插入到页中，先进行一次整理，再次尝试</p>
<p>插入记录是逻辑记录，需要转化成物理记录，然后计算页的容量是否满足。InnoDB要求预留1/16的空间（填充因子）。当发生update时，不需要立即分裂</p>
<p>当逻辑记录转化成物理记录后，需要检查锁信息，生成undo日志，若检测到下一个记录被其他事务持有锁，等待</p>
<p>首先插入，失败进行整理，再次插入，然后更新自适应哈希索引。</p>
<p>插入完成后，可能有行溢出数据，需要对内存对象加x-latch，之后将溢出的列数据放到行溢出页</p>
<h5 id="1052-非主键更新"><a class="markdownIt-Anchor" href="#1052-非主键更新"></a> 10.5.2 非主键更新</h5>
<p>分为乐观和悲观，乐观分为原地更新和普通乐观更新。原地更新只更新记录的列大小没有发生变化。</p>
<p>一般辅助索引更新都不能是原地更新，是delete mark+insert，因为辅助索引更新会导致B+树索引列的值发生变化。</p>
<p>乐观更新前提是主键没有发生变化，仅持有记录页的x-latch</p>
<p>若不能原地更新，原记录会先删除，然后插入新的记录，但主键没变，记录还在同一个页中，只是新旧记录的heap_no发生了变化，需要更新锁信息。（将原记录锁信息移到infimum上，完成后移回来）</p>
<h5 id="1053-主键更新"><a class="markdownIt-Anchor" href="#1053-主键更新"></a> 10.5.3 主键更新</h5>
<p>若更新包含主键更新：</p>
<ol>
<li>将原纪录标记为删除</li>
<li>插入新的主键记录</li>
<li>purge线程判断是否有事务使用原主键记录，没有则删除</li>
</ol>
<p>当主键旧记录有外部溢出页数据时，更新主键，新记录继承溢出页，旧记录取消继承，则只能删除旧记录，不能删除溢出页。若回滚时旧记录继承溢出页，溢出页不能删除</p>
<h5 id="1054-删除"><a class="markdownIt-Anchor" href="#1054-删除"></a> 10.5.4 删除</h5>
<ol>
<li>更新delete flag（事务中完成）</li>
<li>等待purge线程（后台线程）</li>
</ol>
<p>聚簇索引和辅助索引的记录都需要加flag，都是update操作，需要加锁</p>
<p>聚簇索引伪删除需要产生undo log和redo log</p>
<p>乐观删除（只对页加x-latch）条件：</p>
<ol>
<li>
<p>不包含extern属性的列</p>
</li>
<li>
<p>删除不会发生页的合并</p>
</li>
</ol>
<p>悲观删除对内存索引对象加x-latch</p>
<h4 id="106-持久游标"><a class="markdownIt-Anchor" href="#106-持久游标"></a> 10.6 持久游标</h4>
<p>大多少情况下，通过持久游标的对象来处理查询，进行select，update，delete操作时，先定位到第一条记录，开始扫描知道不满足条件。</p>
<p>持久游标用于保存每次查到的记录，查询下一条记录时，首先恢复上一次查询的记录，再获取下一条记录。</p>
<p>扫描过程可能出现页的修改，发生分裂合并等情况，需要每次对保存的记录恢复，然后查找下一条记录</p>
<h4 id="107-自哈希索引"><a class="markdownIt-Anchor" href="#107-自哈希索引"></a> 10.7 自哈希索引</h4>
<p>InnoDB支持自适应哈希索引，根据查询模式，对活页查询页中的记录进行哈希索引</p>
<p>自适应是指哈希索引的创建和维护都是存储引擎自己做的，用户不能自己进行创建操作。仅对热点页所在的数据进行哈希索引。</p>
<p>B+树索引只能找到页，哈希索引找到记录</p>
<p>B+树索引持久化，哈希索引只存在于内存</p>
<p>首先判断页根据访问模式是否已经被请求了17次，若是，判断页根据访问模式是否请求了100次，若是创建哈希索引</p>
<p>每个索引对象保存着索引访问模式，每个页也包含也访问模式信息。通过这两个判断是否进行哈希索引</p>
<h5 id="1072-创建哈希索引"><a class="markdownIt-Anchor" href="#1072-创建哈希索引"></a> 10.7.2 创建哈希索引</h5>
<p>若存在相同哈希键值的记录，InnoDB会进行更新，而不是通过链表解决冲突</p>
<p>使用限制</p>
<ol>
<li>查询开始是没有任何其他事务持有btr_search_latch的x-latch</li>
<li>查询不会引起b+树结构变化，是乐观查询，仅对页加s-latch或x-latch</li>
</ol>
<h5 id="1073-哈希索引维护"><a class="markdownIt-Anchor" href="#1073-哈希索引维护"></a> 10.7.3 哈希索引维护</h5>
<p>自适应哈希的DML开销较大，因为需要持有btr_search_latch的x-latch</p>
<p>删除数据时，若页中记录建立了哈希索引，删除哈希表中记录</p>
<p>插入</p>
<p>更新：</p>
<ol>
<li>原地更新，键值没有变化，不需要维护</li>
<li>更新操作没有更新主键：删除哈希表记录，再次搜索找到记录位置然后插入哈希表</li>
<li>更新并修改主键值：通过删除和插入维护</li>
</ol>
<h5 id="1074-优缺点"><a class="markdownIt-Anchor" href="#1074-优缺点"></a> 10.7.4 优缺点</h5>
<p>优点</p>
<ol>
<li>有较好的查询复杂度</li>
</ol>
<p>缺点</p>
<ol>
<li>btr_search_latch是热点</li>
<li>占用缓冲池内存</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/mysql/innodb/10.B+%E6%A0%91%E7%B4%A2%E5%BC%95/" data-id="ckmixaegx000hasvx3pd07o36" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">John Doe</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>32</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/slorui" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2020 - 2021 John Doe<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>