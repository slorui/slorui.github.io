<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">John Doe</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>45</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-13.事务处理" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/13.%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.065Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事务处理"><a class="markdownIt-Anchor" href="#事务处理"></a> 事务处理</h3>
<h4 id="132-事务"><a class="markdownIt-Anchor" href="#132-事务"></a> 13.2 事务</h4>
<h5 id="1321-概述"><a class="markdownIt-Anchor" href="#1321-概述"></a> 13.2.1 概述</h5>
<p>actomicity：原子性，一起成功或一起失败。事务是不可分割的工作单位。</p>
<p>consistency：一致性：事务将数据库从一种一致状态变为另一种一致状态，事务开始前和结束后数据库的完整性约束没有被破坏</p>
<p>isolation：隔离性，事务之间不可见。当前数据库系统都提供了一种粒度锁策略，只锁实体对象的子集</p>
<p>durable：持久性，事务一旦提交，结果就是永久性的。</p>
<h5 id="1322-分类"><a class="markdownIt-Anchor" href="#1322-分类"></a> 13.2.2 分类</h5>
<ol>
<li>扁平事务</li>
<li>带有保持点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ol>
<h5 id="1323-隔离级别"><a class="markdownIt-Anchor" href="#1323-隔离级别"></a> 13.2.3 隔离级别</h5>
<ol>
<li>read uncommitted：读未提交。产生脏读</li>
<li>read committed：读提交，产生不可重复读</li>
<li>repeatable read：可重复读，产生幻读</li>
<li>serializable：序列化。</li>
</ol>
<p>InnoDB通过repeatable read和Next-Key Lock（间隙锁）避免了幻读</p>
<h4 id="133-事务系统结构"><a class="markdownIt-Anchor" href="#133-事务系统结构"></a> 13.3 事务系统结构</h4>
<h5 id="1331-事务系统段"><a class="markdownIt-Anchor" href="#1331-事务系统段"></a> 13.3.1 事务系统段</h5>
<p>InnoDB有专门的物理位置保存事务的相关信息，称为事务系统段，包含：</p>
<ol>
<li>事务相关信息</li>
<li>回滚段segment header信息</li>
<li>MySQL bin log日志文件位置</li>
<li>doublewrite段信息</li>
</ol>
<h4 id="134-doubewrite段"><a class="markdownIt-Anchor" href="#134-doubewrite段"></a> 13.4 doubewrite段</h4>
<p>InnoDB为了避免partial write问题，使用doublewrite刷新策略，页刷新到磁盘时，批量的刷新到达doublewrite，然后再刷新到对应的位置。</p>
<p>doublewrite段的segment header保存在事务系统段TRX_SYS_DOUBLEWRITE_FSEG之后。doublewrite是顺序写入的，段的分配是分配碎片页，所以doublewrite开始时，先申请32个碎片页，然后申请2MB空间。</p>
<p>doublewrite内存也有2MB空间。进行写入时，先把页复制到doublewrite buffer，double write buffer就行一个2MB的数组，每个元素大小16K，变量first_free表示下一个可以写入的位置，first_free等于128B表示写满</p>
<h4 id="135-undo-日志"><a class="markdownIt-Anchor" href="#135-undo-日志"></a> 13.5 undo 日志</h4>
<h5 id="1351-简介"><a class="markdownIt-Anchor" href="#1351-简介"></a> 13.5.1 简介</h5>
<p>undo日志有两个作用，一个是实现事务的原子性，事务通过undo log回滚。另一个是用来实现一致性非锁定读。</p>
<p>一致性非锁定读指InnoDB通过MVCC读取数据库的数据。如果读的数据正在更新，不会等待写锁释放，会去读一个快照数据</p>
<p>也有undo log是用来回滚事务的，本来就存在，所以快照本身没有开销</p>
<h5 id="1352-结构"><a class="markdownIt-Anchor" href="#1352-结构"></a> 13.5.2 结构</h5>
<p>undo有点特别。其存放是通过两个对象完成的：回滚段和undo段，这里个段的segment header都保存在自己的段内</p>
<p>回滚段保存undo 段segment herder所在页的位置，可以保存1024个undo段信息。</p>
<p>事务系统段一共可以保存156个回滚段，理论最高并发256*1024个事务，mysql仅仅用了1个回滚段，所以只有1024个事务（InnoDB1.1开始支持128个回滚段）</p>
<h5 id="1353-回滚段"><a class="markdownIt-Anchor" href="#1353-回滚段"></a> 13.5.3 回滚段</h5>
<p>回滚段有一个链表，按事务提交顺序逆序存放undo日志，当进行purge时，先读取尾端undo日志，判断是否可以回收该空间</p>
<h5 id="1354-undo段"><a class="markdownIt-Anchor" href="#1354-undo段"></a> 13.5.4 undo段</h5>
<p>undo段才真正存储undo日志。每个回滚段保存了1024个undo段，undo段内存储undo页</p>
<ol>
<li>undo log page header：18个字节</li>
<li>undo log segment haeder（仅仅在undo段的第一个undo页中），30个字节</li>
<li>undo 日志</li>
</ol>
<p>一个undo段有多个undo页，第一个undo页多了segment header，其他每个页有页header和日志</p>
<p>创建undo日志的任何对象时，要先写redo log。恢复时要根据redo恢复undo，然后判断事务回滚还是提交</p>
<p>InnoDB引擎允许一个页存放多个不同事务的undo日志，提交事务时，把undo放入链表，判断页的可用空间是否大于3/4，就可重用。</p>
<p>由于undo log的history链表是以页链接的，而undo页放着不同事务的日志，所以purge需要是涉及磁盘离散读取，比较慢</p>
<p>若undo段中undo页数量大于1，则不可重用</p>
<h4 id="136-undo-记录"><a class="markdownIt-Anchor" href="#136-undo-记录"></a> 13.6 undo 记录</h4>
<h4 id="1361-存储结构"><a class="markdownIt-Anchor" href="#1361-存储结构"></a> 13.6.1 存储结构</h4>
<p>undo日志以逻辑的方式进行存储，意味着回滚只能将数据库逻辑的恢复到原来的样子。数据被逻辑的恢复，但数据结构和页本身可能不太相同。不能将一个页回滚到事务开始的样子，因为有页的并发修改</p>
<p>每个undo log有两部分组成：</p>
<ol>
<li>undo log header：保存每个日志通用信息</li>
<li>undo log record：分为insert undo log和update undo log，除了insert其他DML都是update</li>
</ol>
<p>事务发生DML操作时，分配一个undo log header。insert和update不能放在同一个undo 段，若每个事务都有insert和update，最多就是1024/2=512个事务</p>
<p>insert undo log插入后其他事务看不到，所以事务提交后就能删除</p>
<p>update undo log需要purge线程清理</p>
<p>根据产生的undo log就可把数据恢复到之前的版本，若之前的版本记录undo log未清理，可构建新的版本。（MVCC非锁定读的实现过程）</p>
<h5 id="1362-insert-undo-log-record"><a class="markdownIt-Anchor" href="#1362-insert-undo-log-record"></a> 13.6.2 insert undo log record</h5>
<p>insert undo log包含了日志类型，事务的id，事务第几个操作产生的undo log，操作的表，主键信息等</p>
<p>insert操作不一定会产生insert undo log，可能产生update undo log，例如删除一个主键1的记录然后再插入主键1的记录，当插入记录完全相同，就变成了update undo log</p>
<h5 id="1363-update-undo-log-record"><a class="markdownIt-Anchor" href="#1363-update-undo-log-record"></a> 13.6.3 update undo log record</h5>
<p>改undo要提高mvcc操作，事务结束不能立即删除，放入回滚段的history链表头部，等待purge线程处理</p>
<p>除了事务信息，主要存储以下三部分信息：</p>
<ol>
<li>记录的主键值列表</li>
<li>发生更新的列</li>
<li>索引列：若更新了索引列，方便再purge时删掉对应的辅助索引</li>
</ol>
<p>主键值链表固定存在，后面的两部分信息取决于是否产生这些修改</p>
<p>当一个undo页放不下时，会把之前的删掉，然后再undo段创建新的页然后写入，同时改页不可重用</p>
<h4 id="137-purge"><a class="markdownIt-Anchor" href="#137-purge"></a> 13.7 purge</h4>
<h5 id="1371-清理操作"><a class="markdownIt-Anchor" href="#1371-清理操作"></a> 13.7.1 清理操作</h5>
<p>purge的2个清理操作：</p>
<ol>
<li>清理记录。删除已经标记delete mark的记录或其他相关辅助索引记录</li>
<li>清理undo log。若undo 页中所有undo记录都被删除，清理undo 段</li>
</ol>
<p>只有没有任何事务通过undo日志进行MVCC，才可用清理undo log</p>
<p>innodb会按照事务提交顺序把undo log放到回滚段的history链表（提交顺序逆序）</p>
<p>由于提交导致的事务无序，所有purge要进行大量随机读，purge 再master thread线程完成。忙碌时，秒10秒回收20个undo页。</p>
<h5 id="1372-实现原理"><a class="markdownIt-Anchor" href="#1372-实现原理"></a> 13.7.2 实现原理</h5>
<p>InnoDB中，有一个全局对象保存当前purge的位置与信息。</p>
<p>purge对象持有表的写锁，而drop table需要持有读锁，这就保证了purge时不会删除表</p>
<p>purge对象的latch保证删除的正确性，开始purge时，要先持有写锁，然后看那个undo log可被清理。当MVCC时，需要持有读锁。保证了读的时候不会被删除</p>
<p>可以pruge undo时，处理主键或辅助索引，同时删除对应的undo。如果undo清空，，删除history链表。</p>
<p>当清理到20个页或清空完毕，退出。</p>
<h4 id="138-rollback"><a class="markdownIt-Anchor" href="#138-rollback"></a> 13.8 rollback</h4>
<h4 id="1381-回滚指针"><a class="markdownIt-Anchor" href="#1381-回滚指针"></a> 13.8.1 回滚指针</h4>
<p>InnoDB存储引擎包含roll_ptr（回滚指针）7个字节的隐藏列。指向当前记录的undo log。</p>
<p>因为innodb最多128个undo段（最高位是undo log 的类型），每个页偏移4个字节，页内偏移2个字节，七个字节刚刚好</p>
<h5 id="1382-回滚操作"><a class="markdownIt-Anchor" href="#1382-回滚操作"></a> 13.8.2 回滚操作</h5>
<p>用户态回滚：将事务进行的所有操作都撤销</p>
<p>内核态回滚：存储引擎内部发起的回滚，仅回滚事务最近的一个sql（发生违反约束等，事务未结束，此时之前的数据仍存在，需要用户显示回滚）或回滚整个事务（死锁、事务超时）</p>
<p>回滚时：</p>
<ol>
<li>取得undo log</li>
<li>根据undo log回滚</li>
</ol>
<h4 id="139-commit"><a class="markdownIt-Anchor" href="#139-commit"></a> 13.9 commit</h4>
<p>回滚操作也需要进行事务提交，释放事务持有的资源：undo段，锁，read view等。为了满足持久性，必须刷新redo log，确保写入外存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/13.%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" data-id="ckmixc6t500055cvx0vqn5clk" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-12.缓冲池" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/12.%E7%BC%93%E5%86%B2%E6%B1%A0/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.061Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h3>
<p>磁盘数据库一般通过缓冲池弥补cpu和磁盘速度的差距</p>
<h4 id="122-概述"><a class="markdownIt-Anchor" href="#122-概述"></a> 12.2 概述</h4>
<h5 id="1221-缓冲池"><a class="markdownIt-Anchor" href="#1221-缓冲池"></a> 12.2.1 缓冲池</h5>
<p>页从缓冲池刷新会磁盘不是再每次更新后，而是以一定的频率，通过checkpoint机制刷回磁盘</p>
<p>缓冲池中缓存的数据页类型又：索引页，数据页，undo页，插入缓存，自适应哈希索引，锁信息。</p>
<p>前四个会持久化，自适应哈希和锁信息不会持久化，生命周期再存储引擎运行过程中</p>
<p>每个事务锁信息再trx_struct对象的lock_heap变量分配，当空间大于8KB，就从缓冲池分配，这种情况可能出现大事务</p>
<h5 id="1222-lru-free和flush链表"><a class="markdownIt-Anchor" href="#1222-lru-free和flush链表"></a> 12.2.2 LRU、Free和Flush链表</h5>
<p>缓冲池是一块很大的内存区（16KB的倍数）。</p>
<p>缓冲池有一个free链表，保存至未使用的内存页空间，当free链表页被使用完毕。当再申请空间时，需要LRU算法淘汰使用的页</p>
<p>数据库的缓冲池都是通过LRU算法管理的。InnoDB对LRU进行了优化，LRU加入了midpoint位置，读取的新页放到midpoint位置，位于3/8处，这样可以避免大量数据扫描时把常用页刷出链表</p>
<p>自适应哈希和锁信息的页申请空间后并不放入LRU链表</p>
<p>缓冲池中的页不仅需要被读取，还需要修改，修改的页肯定发生在LRU链表中，当LRU链表页被修改后，被称为脏页。数据库通过checkpoint机制刷回磁盘。flush链表的页就是脏页。脏页既存在于flush，也存在于LRU。</p>
<p>缓冲池mutex已经拆分位缓冲池mutex，flush链表mutex，哈希表re-latch，buf_block_t的mutex</p>
<h4 id="123-缓冲池的管理"><a class="markdownIt-Anchor" href="#123-缓冲池的管理"></a> 12.3 缓冲池的管理</h4>
<h5 id="1231-lru算法"><a class="markdownIt-Anchor" href="#1231-lru算法"></a> 12.3.1 LRU算法</h5>
<h5 id="1232-lru链表维护"><a class="markdownIt-Anchor" href="#1232-lru链表维护"></a> 12.3.2 LRU链表维护</h5>
<h5 id="1233-页的分配"><a class="markdownIt-Anchor" href="#1233-页的分配"></a> 12.3.3 页的分配</h5>
<p>当free_list被分配完毕，需要从LRU链表尾部替换。条件：</p>
<ol>
<li>页不是脏的</li>
<li>页没有其他线程使用</li>
</ol>
<p>如果页是脏的，需要先刷新到磁盘。页如果被其他线程使用，页不能立即替换出去</p>
<p>找到可替换页后，需要对页进行free操作，从缓冲池的哈希表删除页，若有自适应哈希，还删除自适应哈希</p>
<h4 id="124-页的读取"><a class="markdownIt-Anchor" href="#124-页的读取"></a> 12.4 页的读取</h4>
<h5 id="1241-物理读取"><a class="markdownIt-Anchor" href="#1241-物理读取"></a> 12.4.1 物理读取</h5>
<p>InnoDB启动时，缓冲池时空的，所有页都在free链表，数据库读写都再缓冲池完成，这时主要是从外村读取页到缓冲池</p>
<h5 id="1242-随机预读"><a class="markdownIt-Anchor" href="#1242-随机预读"></a> 12.4.2 随机预读</h5>
<p>随机预读指判断某个区域的页是否大多已经被访问，并且是否位热点页，若满足条件，则认位该区域的页都可能被访问，提前进行读取。预读根据某区域内的space和offset顺序读取，可以提高性能。</p>
<p>预取区域根据每32个页进行管理。预读要求32个页的大部分被访问过，默认阈值是9，而且活跃</p>
<h5 id="1243-线性预读"><a class="markdownIt-Anchor" href="#1243-线性预读"></a> 12.4.3 线性预读</h5>
<p>线性预读判断页的访问是否是顺序的，InnoDB就会出发线性预读，连续读取之后的页</p>
<p>读取一个页，若页是某个区域的边界，本区域的部分页被顺序访问，出发线性预读，顺序读取32个页</p>
<h5 id="1244-逻辑读取"><a class="markdownIt-Anchor" href="#1244-逻辑读取"></a> 12.4.4 逻辑读取</h5>
<p>逻辑读取是从缓冲池访问指定的页。若页已经再缓冲池，通过缓冲池的哈希表进行搜索。页需要加锁访问，然而对非叶子节点的访问是通过所有本身的latch保护的，不需要对页加锁</p>
<h4 id="125-页的刷新"><a class="markdownIt-Anchor" href="#125-页的刷新"></a> 12.5 页的刷新</h4>
<h5 id="1251-检查点"><a class="markdownIt-Anchor" href="#1251-检查点"></a> 12.5.1 检查点</h5>
<p>检查点技术解决了以下问题：</p>
<ol>
<li>缩短数据库恢复时间</li>
<li>缓冲池不够时，脏页刷回磁盘</li>
<li>redo log不可用，刷新脏页</li>
</ol>
<p>InnoDB存在两种检查点：</p>
<ol>
<li>Sharp Checkpoint：数据库关闭时所有脏页刷会磁盘</li>
<li>Fuzzy Checkpoint：部分脏页刷回磁盘</li>
</ol>
<p>Fuzzy Checkpoint发生的情况：</p>
<ol>
<li>
<p>Master Thread Checkpoint，每秒和每十秒（异步，不会阻塞用户线程）</p>
</li>
<li>
<p>Asycn/Sync Flush Checkpoint，redo log不可用，强制刷新，此时脏页从flush_list选取</p>
<p>当checkpoint&lt;0.75*redo log size（最大） 不刷藏</p>
<p>当0.75<em>redo log size &lt; checkpoint&lt;0.9</em>redo log size 触发Async刷新，从flush list刷足够的脏页回磁盘满足&lt;0.75</p>
</li>
</ol>
<h5 id="1252-部分写"><a class="markdownIt-Anchor" href="#1252-部分写"></a> 12.5.2 部分写</h5>
<p>页的刷新会遇到部分写，对一个页只写入了一部分内容，如写入4KB（操作系统只保证512B写入原子）</p>
<p>为了避免部分写，实现了doublewrite，页刷新到磁盘时首先写入doublewrite，然后写入磁盘。发生部分写时，通过doublewrite中的页恢复。doublewrite存在于内存表空间，大小位2MB，一次最多进行128页刷新</p>
<h5 id="1253-刷新的实现"><a class="markdownIt-Anchor" href="#1253-刷新的实现"></a> 12.5.3 刷新的实现</h5>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/12.%E7%BC%93%E5%86%B2%E6%B1%A0/" data-id="ckmixc6t300035cvx8ruh1fcy" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-11.insert buffer" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/11.insert%20buffer/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.058Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="insert-buffer"><a class="markdownIt-Anchor" href="#insert-buffer"></a> insert buffer</h3>
<h4 id="112-基本概念"><a class="markdownIt-Anchor" href="#112-基本概念"></a> 11.2 基本概念</h4>
<p>Insert buffer是InnoDB存储引擎独有的，可以大幅提高数据库非唯一约束的辅助索引的插入性能</p>
<p>随机插入会收到辅助索引的影响，因此大批量导入数据时，一半不建议先建立辅助索引，当导入完成后再建立辅助索引</p>
<p>Insert buffer：插入时首先判断插入的辅助索引叶子是否再缓冲池中，若再直接插入，否则插入的记录放在insert buffer中，根据一些算法将记录通过后台线程慢慢的merge到辅助索引页。好处是：</p>
<ol>
<li>减少磁盘离散读取</li>
<li>将多次插入合并为一次操作</li>
</ol>
<p>insert buffer只能缓存非唯一约束索引，唯一索引需要判断插入记录是否唯一，还需要读取辅助索引页。</p>
<h4 id="113-架构实现"><a class="markdownIt-Anchor" href="#113-架构实现"></a> 11.3 架构实现</h4>
<h5 id="1131-存储结构"><a class="markdownIt-Anchor" href="#1131-存储结构"></a> 11.3.1 存储结构</h5>
<p>Insert Buffer也是一棵B+树。键值为待插入辅助索引页的page_no。Insert Buffer默认最多占缓冲池的一半。</p>
<p>Insert Buffer会把插入的辅助索引记录缓存起来，但是必须保证缓存的记录不会引起页的分裂。当缓存记录过多，会主动读取辅助索引页，将记录合并回页，然后进行悲观插入操作。InnoDB 存在也该Insert Buffer bitmap页，用来追踪每个辅助索引页的剩余空间，当小于某阈值（512B）就必须主动合并。</p>
<p>以为一个Insert Buffer bitmap只能追踪一个辅助索引页2KB的空间，所以Insert Buffer 最多缓存2KB。</p>
<p>B+树索引由两个段，root页保存了非叶子节点段和页节点段的段头信息</p>
<p>insert buffer只有一个数据段，存放所有非叶子节点和页节点。</p>
<h5 id="1132-逻辑控制"><a class="markdownIt-Anchor" href="#1132-逻辑控制"></a> 11.3.2 逻辑控制</h5>
<p>insert buffer的合并分为主动和被动。</p>
<p>主动是指master thread定期随机将记录合并到辅助索引页。每秒有处理能力就合并五个，每十秒必定处理五个</p>
<p>被动是指用户主动发起辅助索引页的读取操作，回被动的将记录合并到辅助索引页。由于辅助索引页已经读取到缓冲池，后续插入不会记录到insert buffer</p>
<h4 id="114-相关数据结构"><a class="markdownIt-Anchor" href="#114-相关数据结构"></a> 11.4 相关数据结构</h4>
<h4 id="115-死锁"><a class="markdownIt-Anchor" href="#115-死锁"></a> 11.5 死锁</h4>
<h5 id="1151-latch顺序"><a class="markdownIt-Anchor" href="#1151-latch顺序"></a> 11.5.1 latch顺序</h5>
<p>当辅助索引页读取到缓存而这时发生merge，可能回引起insert buffer索引树的收缩，所以需要持有insert buffer索引树内存对象x-latch</p>
<p>还有就是异步I/O，当所有线程都在读取辅助索引页，而辅助索引页又需要合并，没有线程能读insert buffer树，就出现了死锁</p>
<p>为了方式死锁，InnoDB页的逻辑页分为三个层次</p>
<ol>
<li>非insert buffer页</li>
<li>除了insert buffer bitmap页的insert buffer页</li>
<li>insert buffer bitmap页</li>
</ol>
<p>insert buffer有独立的文件空间管理，insert buffer页的段都保存再root页的free list链表中，当进行insert buffer 树的扩展或收缩时，先判断freelist是否有足够的页，这就使得fsp模块与insert buffer模块分离，避免了死锁</p>
<h5 id="1152-并发控制"><a class="markdownIt-Anchor" href="#1152-并发控制"></a> 11.5.2 并发控制</h5>
<p>引入了四个insert buffer latch</p>
<h5 id="1153-异步io线程"><a class="markdownIt-Anchor" href="#1153-异步io线程"></a> 11.5.3 异步I/O线程</h5>
<p>由于读取辅助索引页发起了异步I/O，因此当Insert buffer合并时，又发起了异步I/O，会陷入等待状态</p>
<p>将insert buffer的异步I/O放入一个单独的I/O线程</p>
<h4 id="116-维护"><a class="markdownIt-Anchor" href="#116-维护"></a> 11.6 维护</h4>
<h5 id="1161-记录合并"><a class="markdownIt-Anchor" href="#1161-记录合并"></a> 11.6.1 记录合并</h5>
<p>无论是主动还是被动，顺序都是先读取辅助索引页，再读取insert buffer页</p>
<h5 id="1162-空间收缩"><a class="markdownIt-Anchor" href="#1162-空间收缩"></a> 11.6.2 空间收缩</h5>
<p>当删除insert buffer中的记录时，这些页会从树删除，放入free list头部，然后通过收缩将页放回insert buffer段的空间</p>
<p>为了避免每次回收占用大量空间，每次最多回收4个页</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/11.insert%20buffer/" data-id="ckmixc6t200025cvx6f961uyw" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-10.B+树索引" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/10.B+%E6%A0%91%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.056Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="b树索引"><a class="markdownIt-Anchor" href="#b树索引"></a> B+树索引</h3>
<h4 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B+树</h4>
<h5 id="1011-概述"><a class="markdownIt-Anchor" href="#1011-概述"></a> 10.1.1 概述</h5>
<p>B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，所有记录节点都按键值大小顺序存放在同一层叶子节点，各节点指针相连</p>
<h5 id="1012-插入"><a class="markdownIt-Anchor" href="#1012-插入"></a> 10.1.2 插入</h5>
<p>三种情况：</p>
<ol>
<li>叶子，索引都没满：直接插入</li>
<li>叶子满，索引没满：插入，分裂叶子</li>
<li>叶子满，索引满：插入，分裂叶子和索引</li>
</ol>
<p>B+树主要作用于磁盘，因此要减少分裂操作，B+树也提高了旋转功能</p>
<p>旋转发生在页子满时，其左右兄弟节点没满，将记录转移到左右兄弟节点上</p>
<h5 id="1013-删除"><a class="markdownIt-Anchor" href="#1013-删除"></a> 10.1.3 删除</h5>
<p>B+树使用填充因子控制树的删除变化，50%是填充因子的最小值</p>
<p>三种情况</p>
<ol>
<li>叶子和索引都不小于填充因子：直接删除，如果该节点还是索引页的节点，用右节点代替</li>
<li>叶子节点小于填充因子：合并叶子节点和兄弟节点，更新索引</li>
<li>都小于填充因子：合并叶子节点和兄弟，更新索引，合并索引和兄弟节点</li>
</ol>
<h4 id="102-b树索引"><a class="markdownIt-Anchor" href="#102-b树索引"></a> 10.2 B+树索引</h4>
<h5 id="1021-索引的特点"><a class="markdownIt-Anchor" href="#1021-索引的特点"></a> 10.2.1 索引的特点</h5>
<h5 id="1022-聚簇索引"><a class="markdownIt-Anchor" href="#1022-聚簇索引"></a> 10.2.2 聚簇索引</h5>
<p>聚簇索引是将表的主键作为键值构建的B+树</p>
<p>聚簇索引的记录是按键值顺序存放的，是逻辑顺序，不是物理顺序，开销太大</p>
<h5 id="1023-辅助索引"><a class="markdownIt-Anchor" href="#1023-辅助索引"></a> 10.2.3 辅助索引</h5>
<p>辅助索引称为二级索引或非聚簇索引。辅助索引的叶子节点保存&lt;键值，记录地址&gt;。聚簇索引页中保存的是下层页的地址，辅助索引页子节点保存记录的地址。记录的地址一般有</p>
<ol>
<li>记录的物理地址，页号，槽号：偏移量（MyISAM，没有聚簇索引，记录放在堆表中，主键索引和非主键索引没区别，只是唯一并且非空）</li>
<li>记录的主键值（InnoDB）</li>
</ol>
<p>因为辅助索引叶子节点存放主键，所有还需要通过一次聚簇索引查询，回表</p>
<p>辅助索引非叶子节点存放记录&lt;键值、主键值、地址&gt;，辅助索引的非叶子节点也存在主键值信息，辅助索引节点不保存因此列（事务id和undo指针）</p>
<h5 id="1024-填充因子"><a class="markdownIt-Anchor" href="#1024-填充因子"></a> 10.2.4 填充因子</h5>
<p>因为小于0.5就会合并，索引填充因子大于0.5，顺序插入可能达到0.9以上，一般为0.69</p>
<h4 id="103-innodb的b树实现"><a class="markdownIt-Anchor" href="#103-innodb的b树实现"></a> 10.3 InnoDB的B+树实现</h4>
<h5 id="1032-相关latch"><a class="markdownIt-Anchor" href="#1032-相关latch"></a> 10.3.2 相关latch</h5>
<p>B+树索引的并发控制通过两部分latch进行，每个页都有一个读写锁，每个索引树对象中还有一个读写锁，可以理解为非叶子节点的读写锁（或B+树索引的读/写锁）</p>
<h5 id="1033-整理"><a class="markdownIt-Anchor" href="#1033-整理"></a> 10.3.3 整理</h5>
<p>InnoDB中页是一个无序堆，记录之间通过record header的next header串联。删除记录时，记录所占用的空间放到链表page-free，下次再分配空间时查找第一个空间是否满足，满足则分配记录空间，否则从page-heap-top分配</p>
<p>对页进行DML操作时，若页空间不足，先进行整理操作，空间仍不够，进行分裂</p>
<p>对页整理时，先加x-latch，该操作仅记录重做日志的类型。</p>
<h5 id="1034-分裂"><a class="markdownIt-Anchor" href="#1034-分裂"></a> 10.3.4 分裂</h5>
<p>InnoDB索引存在磁盘，所以对B+树索引进行了优化，不再将中间记录作为分裂点，而是根据插入情况判断，有效利用磁盘空间</p>
<p>分裂时，先判断拆入模式（递增，递减，无序）</p>
<p>步骤：</p>
<ol>
<li>确定分裂点记录</li>
<li>从索引数据段分配一个新页，加上x-latch</li>
<li>确定需要移动页中开始的第一个记录和移动到的记录</li>
<li>更新上层节点记录</li>
<li>将记录移到新页</li>
<li>待插入记录插入页</li>
<li>若插入失败，页重新组织，再次进行插入</li>
<li>若上述失败，再次去1进行分裂</li>
</ol>
<h5 id="1035-合并"><a class="markdownIt-Anchor" href="#1035-合并"></a> 10.3.5 合并</h5>
<p>更新或删除后，页的填充率可能小于0.5，这是会进行合并，若左右节点没有空间，不进行合并</p>
<p>先对内存对象和待合并页加锁，然后合并页判断左兄弟，左兄弟存在，就合并左兄弟，及时空间不足，也不合并右兄弟</p>
<h4 id="104-查找"><a class="markdownIt-Anchor" href="#104-查找"></a> 10.4 查找</h4>
<h5 id="1041-mode"><a class="markdownIt-Anchor" href="#1041-mode"></a> 10.4.1 mode</h5>
<p>查询可能为小于，小于等于，大于，大于等于等，但再非叶子节点查询只能是小于或小于等于。对于插入，只能是小于等于，找到插入记录的前一条记录。</p>
<p>若对主键或唯一索引进行查询，使用大于等于，因为InnoDB支持MVCC，即使进行了唯一约束，但页内也可能存在多个键值相同记录（例如被标记为删除的记录）。</p>
<p>当再一个页查询不到，查到supernm时，会继续去下一个页查询</p>
<h5 id="1042-latch-mode"><a class="markdownIt-Anchor" href="#1042-latch-mode"></a> 10.4.2 latch mode</h5>
<p>InnoDB总是先对索引内存对象加上s-latch，然后进行页操作，或insert、update、delete不会导致非叶子节点变化（分裂、合并、树的高度变化）立即释放内存对象s-latch（乐观方式）、否则，换成x-latch（悲观方式）</p>
<h5 id="1043-cursor"><a class="markdownIt-Anchor" href="#1043-cursor"></a> 10.4.3 cursor</h5>
<h4 id="105-dml操作"><a class="markdownIt-Anchor" href="#105-dml操作"></a> 10.5 DML操作</h4>
<h5 id="1051-插入"><a class="markdownIt-Anchor" href="#1051-插入"></a> 10.5.1 插入</h5>
<p>InnoDB插入分为两部分，首先调用乐观插入，如果发生分裂等，调用悲观插入</p>
<p>乐观插入时，发现不能插入到页中，先进行一次整理，再次尝试</p>
<p>插入记录是逻辑记录，需要转化成物理记录，然后计算页的容量是否满足。InnoDB要求预留1/16的空间（填充因子）。当发生update时，不需要立即分裂</p>
<p>当逻辑记录转化成物理记录后，需要检查锁信息，生成undo日志，若检测到下一个记录被其他事务持有锁，等待</p>
<p>首先插入，失败进行整理，再次插入，然后更新自适应哈希索引。</p>
<p>插入完成后，可能有行溢出数据，需要对内存对象加x-latch，之后将溢出的列数据放到行溢出页</p>
<h5 id="1052-非主键更新"><a class="markdownIt-Anchor" href="#1052-非主键更新"></a> 10.5.2 非主键更新</h5>
<p>分为乐观和悲观，乐观分为原地更新和普通乐观更新。原地更新只更新记录的列大小没有发生变化。</p>
<p>一般辅助索引更新都不能是原地更新，是delete mark+insert，因为辅助索引更新会导致B+树索引列的值发生变化。</p>
<p>乐观更新前提是主键没有发生变化，仅持有记录页的x-latch</p>
<p>若不能原地更新，原记录会先删除，然后插入新的记录，但主键没变，记录还在同一个页中，只是新旧记录的heap_no发生了变化，需要更新锁信息。（将原记录锁信息移到infimum上，完成后移回来）</p>
<h5 id="1053-主键更新"><a class="markdownIt-Anchor" href="#1053-主键更新"></a> 10.5.3 主键更新</h5>
<p>若更新包含主键更新：</p>
<ol>
<li>将原纪录标记为删除</li>
<li>插入新的主键记录</li>
<li>purge线程判断是否有事务使用原主键记录，没有则删除</li>
</ol>
<p>当主键旧记录有外部溢出页数据时，更新主键，新记录继承溢出页，旧记录取消继承，则只能删除旧记录，不能删除溢出页。若回滚时旧记录继承溢出页，溢出页不能删除</p>
<h5 id="1054-删除"><a class="markdownIt-Anchor" href="#1054-删除"></a> 10.5.4 删除</h5>
<ol>
<li>更新delete flag（事务中完成）</li>
<li>等待purge线程（后台线程）</li>
</ol>
<p>聚簇索引和辅助索引的记录都需要加flag，都是update操作，需要加锁</p>
<p>聚簇索引伪删除需要产生undo log和redo log</p>
<p>乐观删除（只对页加x-latch）条件：</p>
<ol>
<li>
<p>不包含extern属性的列</p>
</li>
<li>
<p>删除不会发生页的合并</p>
</li>
</ol>
<p>悲观删除对内存索引对象加x-latch</p>
<h4 id="106-持久游标"><a class="markdownIt-Anchor" href="#106-持久游标"></a> 10.6 持久游标</h4>
<p>大多少情况下，通过持久游标的对象来处理查询，进行select，update，delete操作时，先定位到第一条记录，开始扫描知道不满足条件。</p>
<p>持久游标用于保存每次查到的记录，查询下一条记录时，首先恢复上一次查询的记录，再获取下一条记录。</p>
<p>扫描过程可能出现页的修改，发生分裂合并等情况，需要每次对保存的记录恢复，然后查找下一条记录</p>
<h4 id="107-自哈希索引"><a class="markdownIt-Anchor" href="#107-自哈希索引"></a> 10.7 自哈希索引</h4>
<p>InnoDB支持自适应哈希索引，根据查询模式，对活页查询页中的记录进行哈希索引</p>
<p>自适应是指哈希索引的创建和维护都是存储引擎自己做的，用户不能自己进行创建操作。仅对热点页所在的数据进行哈希索引。</p>
<p>B+树索引只能找到页，哈希索引找到记录</p>
<p>B+树索引持久化，哈希索引只存在于内存</p>
<p>首先判断页根据访问模式是否已经被请求了17次，若是，判断页根据访问模式是否请求了100次，若是创建哈希索引</p>
<p>每个索引对象保存着索引访问模式，每个页也包含也访问模式信息。通过这两个判断是否进行哈希索引</p>
<h5 id="1072-创建哈希索引"><a class="markdownIt-Anchor" href="#1072-创建哈希索引"></a> 10.7.2 创建哈希索引</h5>
<p>若存在相同哈希键值的记录，InnoDB会进行更新，而不是通过链表解决冲突</p>
<p>使用限制</p>
<ol>
<li>查询开始是没有任何其他事务持有btr_search_latch的x-latch</li>
<li>查询不会引起b+树结构变化，是乐观查询，仅对页加s-latch或x-latch</li>
</ol>
<h5 id="1073-哈希索引维护"><a class="markdownIt-Anchor" href="#1073-哈希索引维护"></a> 10.7.3 哈希索引维护</h5>
<p>自适应哈希的DML开销较大，因为需要持有btr_search_latch的x-latch</p>
<p>删除数据时，若页中记录建立了哈希索引，删除哈希表中记录</p>
<p>插入</p>
<p>更新：</p>
<ol>
<li>原地更新，键值没有变化，不需要维护</li>
<li>更新操作没有更新主键：删除哈希表记录，再次搜索找到记录位置然后插入哈希表</li>
<li>更新并修改主键值：通过删除和插入维护</li>
</ol>
<h5 id="1074-优缺点"><a class="markdownIt-Anchor" href="#1074-优缺点"></a> 10.7.4 优缺点</h5>
<p>优点</p>
<ol>
<li>有较好的查询复杂度</li>
</ol>
<p>缺点</p>
<ol>
<li>btr_search_latch是热点</li>
<li>占用缓冲池内存</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/10.B+%E6%A0%91%E7%B4%A2%E5%BC%95/" data-id="ckmixc6t100015cvx98jt3sm3" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-9.锁" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/9.%E9%94%81/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.053Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h3>
<p>InnoDB通过next-ket+可重复读解决了幻读的问题</p>
<p>InnoDB锁很高效，DML不总是产生锁对象</p>
<p>锁对象通过位图实现，内存开销小，不存在锁升级问题</p>
<h4 id="92-锁和事务"><a class="markdownIt-Anchor" href="#92-锁和事务"></a> 9.2 锁和事务</h4>
<h5 id="921-隔离性"><a class="markdownIt-Anchor" href="#921-隔离性"></a> 9.2.1 隔离性</h5>
<p>隔离性是ACID的I，锁就是实现事务的隔离性和一致性</p>
<p>隔离性要求：事务各自运行时，运行不受到其他事务的影响，提交前也看不到其他事务的结果。</p>
<p>要求用一种简单的算法或开销小的算法实现加锁技术，不能比串行化还慢</p>
<p>锁是一个串行机制，保证同一时刻只能被一个事务访问</p>
<p>MyISAM是表锁，并发没问题，并发写效率较差，如果是底部插入，有并发写入操作</p>
<p>SQLserver开始是页锁，后来支持悲观乐观并发，但是会锁升级到表锁，</p>
<h5 id="922-事务隔离级别"><a class="markdownIt-Anchor" href="#922-事务隔离级别"></a> 9.2.2 事务隔离级别</h5>
<p>脏写：两个事务先后修改了同一值，先事务进行了回滚，后事务的值没了</p>
<p>脏读：读取到了未提交的数据</p>
<p>不可重复读：两次读取的数据不同（不保证产生新的行）</p>
<h5 id="923-幻读"><a class="markdownIt-Anchor" href="#923-幻读"></a> 9.2.3 幻读</h5>
<p>幻读指统一事务下，连续两次同样的sql导致结果不同，第二次sql可能返回之前不存在的行</p>
<p>谓词锁：锁定的不是单个记录，而是一个条件</p>
<p>key-range locking算法是谓词锁的改进，锁定的是范围</p>
<p>根据范围分为next-key locking和previous-key locking</p>
<p>（-∞,W]，(W,Y],(Y,Z],(Z,+∞)<br />
范围被锁定时，阻止其他事务向这个范围内插入记录</p>
<h4 id="93-锁的类型和算法"><a class="markdownIt-Anchor" href="#93-锁的类型和算法"></a> 9.3 锁的类型和算法</h4>
<p>共享锁（S lock），允许事务读一行数据</p>
<p>排他锁（X lock），允许事务删除或更新一行数据</p>
<p>InnoDB支持多粒度锁定，允许事务在行记录或表记录同时加锁，为了多粒度锁，InnoDB支持了意向锁</p>
<p>意向锁把锁定对象分为多个层次，意味着事务希望在更细粒度上加锁</p>
<p>将上锁对象当初一棵树，要对下层节点上锁，需要先对上层对象加锁，要加x-lock，先对上层加意向锁IX，若某一部分导致等待，都需要等待粗粒度锁完成</p>
<p>InnoDB意向锁即表级别的锁，目的是为了在一个事务中揭示下一行被将被请求的锁类型</p>
<p>意向共享锁（IS）事务想获得一张表某几行的共享锁</p>
<p>意向排他锁（IX）事务想获得一张表某几行的排他锁</p>
<p><strong>意向锁的兼容性是相对表锁来的</strong></p>
<p>InnoDB是行级锁，因此意向锁不会阻塞全表扫描外的请求。</p>
<p>InnoDB支持的三种行锁</p>
<ol>
<li>record lock：记录锁</li>
<li>gap lock：间隙锁，锁定一个范围，不包含记录本身</li>
<li>next-key lock，邻键锁，间隙锁+记录锁，锁定范围+本身</li>
</ol>
<h4 id="94-锁内部实现"><a class="markdownIt-Anchor" href="#94-锁内部实现"></a> 9.4 锁内部实现</h4>
<p>页中还存有位图信息，由于位图大小可变，没有显示定义大小</p>
<p>记录是否有锁，通过位图的bit位判断</p>
<p>InnoDB支持表锁：意向锁和自增锁</p>
<p>事务信息中包含每个页的锁信息，然后多个页的锁信息链接起来</p>
<p>这种查询方式看起来不高效，但是节省了大量开销，若对每一个锁进行管理，开销会非常巨大。</p>
<p>锁查询的两种方式：</p>
<ol>
<li>根据事务：事务会维护一个内存对象，包含事务锁信息链表和指向正在等待的锁信息</li>
<li>根据记录：根据记录所在的页进行哈希查询，通过位图进行判断</li>
</ol>
<h5 id="942-锁的并发控制"><a class="markdownIt-Anchor" href="#942-锁的并发控制"></a> 9.4.2 锁的并发控制</h5>
<h4 id="95-显示锁和隐式锁"><a class="markdownIt-Anchor" href="#95-显示锁和隐式锁"></a> 9.5 显示锁和隐式锁</h4>
<p>分为explicit显示锁和implicit隐式锁</p>
<p>显示锁分为间隙显示锁（仅锁住范围）和非间隙显示锁（锁记录和记录之前的范围），可以是读锁页可以是写锁</p>
<p>隐式锁总时写锁</p>
<p>显示锁直接加锁，隐式锁是指索引记录逻辑上有写锁，内存不包含这个锁信息，没有任何内存开销，可以位于聚簇索引，也可以位于辅助索引。</p>
<p>聚簇索引插入一条记录，未提交时，就包含一个隐式锁。</p>
<p>对辅助索引进行update，产生隐式锁。并不是每次都产生隐式锁，若加锁需要等待，产生显示锁，因为后面需要被唤醒</p>
<p>由于隐式锁存在，加锁前需要把隐式锁转化成显示锁，并加信息插入全局哈希表中</p>
<h5 id="952-聚簇索引隐式锁"><a class="markdownIt-Anchor" href="#952-聚簇索引隐式锁"></a> 9.5.2 聚簇索引隐式锁</h5>
<p>每个索引记录都有一个事务id隐藏列，判断事务id读取是否为活跃事务，活跃事务有隐式锁。</p>
<h5 id="953-辅助索引记录的隐式锁"><a class="markdownIt-Anchor" href="#953-辅助索引记录的隐式锁"></a> 9.5.3 辅助索引记录的隐式锁</h5>
<p>每个辅助索引页通过page header保存一个最大事务id，当索引中任何记录被更新，更新这个最大id</p>
<ol>
<li>根据辅助索引页的最大事务id判断</li>
<li>根据聚簇索引记录进行判断</li>
</ol>
<p>当最大事务id小于活跃事务id，不包含隐式锁，之前已经提交的事务修改了该记录。若等于：</p>
<ol>
<li>存在活跃事务修改了辅助索引记录，导致最大事务id更新</li>
<li>存在事务（可能活跃（未提交），也可能完成了提交），修改了页中其他辅助索引记录，导致最大事务id更新</li>
</ol>
<p><strong>隐式锁就是会自己判断是否阻塞</strong></p>
<h4 id="96-加锁操作"><a class="markdownIt-Anchor" href="#96-加锁操作"></a> 9.6 加锁操作</h4>
<h5 id="961-加锁流程"><a class="markdownIt-Anchor" href="#961-加锁流程"></a> 9.6.1 加锁流程</h5>
<p>产生的锁对象加入到表队列的locks链表中，遍历次链表可以得出表上所有锁信息</p>
<p>对行记录加锁需要注意：</p>
<ol>
<li>是否为隐私锁，隐式锁并且没有冲突，不需要产生锁对象，否则产生对象并加入等待队列</li>
<li>锁对象是否可以重用，前提是同一个事务锁同一页记录，而且模式相同，或锁同一记录，第二次锁强度弱</li>
</ol>
<p>InnoDB锁是根据事务和页进行管理和组织的</p>
<p>哈希表只能找到记录所在页的锁对象，然后通过位图查找</p>
<h5 id="962-加锁过程"><a class="markdownIt-Anchor" href="#962-加锁过程"></a> 9.6.2 加锁过程</h5>
<ol>
<li>通过主键加锁的语句，仅对聚簇索引记录加锁</li>
<li>通过辅助索引加锁的语句，首先对辅助索引记录加锁，再对聚簇索引记录加锁</li>
<li>通过辅助索引记录加锁的语句，可能还需要对下一条记录加锁（避免幻读），若为唯一约束，则不需要，否则可能会再第二次读取时读到新插入的数据</li>
</ol>
<h4 id="97-行锁的维护"><a class="markdownIt-Anchor" href="#97-行锁的维护"></a> 9.7 行锁的维护</h4>
<p>锁对象映射到哈希桶中</p>
<h5 id="971-插入"><a class="markdownIt-Anchor" href="#971-插入"></a> 9.7.1 插入</h5>
<ol>
<li>对表加IX锁</li>
<li>根据查询模式定位记录位置</li>
<li>判断记录是否有锁，有就等待是否，没有就插入</li>
<li>若有辅助索引，还需根据2，3进行锁判断，插入后需要更新最大事务id</li>
</ol>
<p>插入记录需要定位下一条记录，这是next-key lock邻键锁算法要求，要获取下一个记录的锁，如果有锁 说明当前区域被锁定，不能插入。插入后还需要更新锁定范围</p>
<h5 id="972-更新"><a class="markdownIt-Anchor" href="#972-更新"></a> 9.7.2 更新</h5>
<p>更新（删除）前，先尝试加x（隐式）锁，若存在其他锁，事务被阻塞，等待锁释放</p>
<ol>
<li>聚簇索引加锁成功，转化为显示锁</li>
<li>辅助索引加锁成功，更新最大事务id</li>
</ol>
<p>若不能原地更新，需要把锁信息移到infinum记录上</p>
<h5 id="973-purge"><a class="markdownIt-Anchor" href="#973-purge"></a> 9.7.3 purge</h5>
<p>对标记删除的记录真正删除后，需要更新下一个记录的锁定范围。考虑时注意</p>
<h5 id="974-一致性锁定读"><a class="markdownIt-Anchor" href="#974-一致性锁定读"></a> 9.7.4 一致性锁定读</h5>
<p>默认情况，InnoDB使用一致性非锁定读。某些情况需要使用一致性锁定读保证数据的一致性，可以用lokc in share mode和for update加锁。</p>
<h5 id="975-页的分裂"><a class="markdownIt-Anchor" href="#975-页的分裂"></a> 9.7.5 页的分裂</h5>
<p>当插入导致分裂时</p>
<ol>
<li>确定分裂点记录</li>
<li>分裂点到supernum锁移到到新页，修改bitmap</li>
<li>调用函数将原superme移到新的superme（原gap锁后移）</li>
<li>将新页的第一条记录锁信息移到前页的superme（原gap锁前移）</li>
</ol>
<h5 id="976-页的合并"><a class="markdownIt-Anchor" href="#976-页的合并"></a> 9.7.6 页的合并</h5>
<ol>
<li>记录左页的最后一条记录</li>
<li>右页记录移到左页，更新锁信息</li>
<li>左页superme移到保存的左页最后一条记录</li>
<li>右页superme移到左页superme</li>
</ol>
<h4 id="98-自增锁"><a class="markdownIt-Anchor" href="#98-自增锁"></a> 9.8 自增锁</h4>
<p>自增锁插入后即释放，不会等事务提交才释放</p>
<p>自增长值并不持久化，而是每次启动时查询最大获得</p>
<p>自增锁和表的读写锁不互容</p>
<h4 id="99-死锁"><a class="markdownIt-Anchor" href="#99-死锁"></a> 9.9 死锁</h4>
<h5 id="991-死锁的概念"><a class="markdownIt-Anchor" href="#991-死锁的概念"></a> 9.9.1 死锁的概念</h5>
<p>两个或两个以上事务争夺资源的过程中互相等待的现象。</p>
<p>解决死锁的基本办法是超时回滚。</p>
<p>除了超时机制，数据库一般还采用等待图的方式进行死锁检查，保存了两种信息：</p>
<ol>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ol>
<p>若链表构造的图出现回路，就代表产生了死锁。采用深度优先搜索算法，每次加锁需要等待时，就调用判断是否会产生死锁，有就回滚事务</p>
<h5 id="992-死锁概率"><a class="markdownIt-Anchor" href="#992-死锁概率"></a> 9.9.2 死锁概率</h5>
<p>死锁概率=(n^2 * r^4)/4R   n是事务量，R是记录量</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/9.%E9%94%81/" data-id="ckmixc6ta000c5cvxeklbf1yr" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-8.索引页" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/8.%E7%B4%A2%E5%BC%95%E9%A1%B5/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.048Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引页"><a class="markdownIt-Anchor" href="#索引页"></a> 索引页</h3>
<p>InnoDB是索引组织表，聚簇索引的叶子节点存放着完整的记录，辅助索引页中存放着指向叶子节点的书签</p>
<h4 id="82-页"><a class="markdownIt-Anchor" href="#82-页"></a> 8.2 页</h4>
<p>InnoDB定义了两种页，索引页和日志页</p>
<p>由于是索引组织表，索引即数据，索引页就是数据页</p>
<h4 id="83-存储结构"><a class="markdownIt-Anchor" href="#83-存储结构"></a> 8.3 存储结构</h4>
<h5 id="831-page-header"><a class="markdownIt-Anchor" href="#831-page-header"></a> 8.3.1 Page Header</h5>
<p>page header保存页的信息，占56个字节，每个页都有两个伪记录。当删除页中记录时，page_free指向最近删除的空间，通过记录record header中的next header串联得到一个空闲链表</p>
<p>当记录申请空间时，检查page_free的空间是否够用，不够用直接去page_heap_top申请，不会遍历链表，之前的空间不会被重用。当页空间不足时，会进行页重新组织，根据主键记录排序，整理碎片空间</p>
<p>页记录是根据主键顺序排列的，顺序是逻辑上的，不是物理的（开销很大）。因此页是一个存储记录的堆，其中记录无序。</p>
<p>在传统B+树，分裂操作向左进行。InnoDB根据值判断插入放心，顺序升序插入、顺序降序插入、无序随机插入导致不同的分裂策略。</p>
<p>为了更好的顺序性存储，叶子和非叶子节点存放在不同的段对象中。</p>
<h5 id="832-page-directory"><a class="markdownIt-Anchor" href="#832-page-directory"></a> 8.3.2 page directory</h5>
<p>当进行记录查询，需要page directory。B+树只能查询到页，然后根据page directory（位于页的尾部）定位。</p>
<p>page directory由槽组成（slot），每个槽两个字节，按主键顺序逆序。</p>
<p>为了提高存储和插入效率，槽采用稀疏方式，每个槽对应了一个记录，每个槽总时包含4-8条记录。槽保证在一定范围内，当超过范围，槽会分裂产生新的槽，当低于数量，会平衡槽中记录数，可能导致删除和合并槽</p>
<h4 id="84-page-cursor"><a class="markdownIt-Anchor" href="#84-page-cursor"></a> 8.4 Page Cursor</h4>
<h5 id="841-定位记录"><a class="markdownIt-Anchor" href="#841-定位记录"></a> 8.4.1 定位记录</h5>
<p>page cursor是一个指向记录所在位置的游标，用来定位记录，通过查询模式向前或向后扫描记录</p>
<p>由于page directory是稀疏机构，因此首先通过二叉查找定位记录所在槽，然后通过二叉查找的扫描记录。</p>
<h5 id="842-插入记录"><a class="markdownIt-Anchor" href="#842-插入记录"></a> 8.4.2 插入记录</h5>
<p>插入的记录可以是物理记录，也可是逻辑记录。通常是逻辑记录，转化成物流记录。cursor指向插入记录之前的记录</p>
<p>插入记录会对页进行修改，会产生redo log。插入的redo log就是cursor定位的记录偏移量+插入的记录。为了性能，进行记录压缩。策略是找到cursor记录和当前记录的第一个不同字节，不需要对前面重复的内容记录。</p>
<p>记录插入通常将逻辑记录插入页，记录插入完成后，需要对page directory维护，看看槽是否需要平衡</p>
<h5 id="843-删除记录"><a class="markdownIt-Anchor" href="#843-删除记录"></a> 8.4.3 删除记录</h5>
<p>将记录标记为删除，然后将记录的空间放到page_header的page_free前端。需要对page directory维护</p>
<p>删除的redo log，额外的记录删除记录在页中的偏移量</p>
<h5 id="844-并发控制"><a class="markdownIt-Anchor" href="#844-并发控制"></a> 8.4.4 并发控制</h5>
<p>对于索引页的并发控制是在上层的调用中进行的，索引页不加锁</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/8.%E7%B4%A2%E5%BC%95%E9%A1%B5/" data-id="ckmixc6ta000b5cvxbemxex2l" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-7.记录" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/7.%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.044Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="记录"><a class="markdownIt-Anchor" href="#记录"></a> 记录</h3>
<h4 id="72概述"><a class="markdownIt-Anchor" href="#72概述"></a> 7.2概述</h4>
<p>InnoDB是一种面向行的存储引擎，每个页以行记录的方式存储。基于行的好处</p>
<ol>
<li>记录放在同一页，访问一条记录需要访问的页很少</li>
<li>符合机械磁盘的访问方式</li>
<li>容易理解，数据存取就像二维表访问</li>
</ol>
<p>通常行和记录是等价的。关系数据库理论中，元组描述记录，字段描述列</p>
<p>物理记录是数据在物理存储中的格式，逻辑记录就像数组，内部放着一条条记录</p>
<p>InnoDB引擎是索引组织表(index organized table,IOT)，意味着所有用户数据都是B+树存储。叶子节点存放着每行记录，若没有主键，字段创建一个6字节的隐藏列当作主键。</p>
<p>InnoDB支持事务和MVCC，每行记录还包含了一个回滚指针以及记录事务ID的列（都是隐藏列）。回滚指针用来构造上一个版本，实现MVCC，事务ID判断当前记录其他事务是否可见，实现事务隔离和ＭＶＣＣ</p>
<h4 id="73-物理记录"><a class="markdownIt-Anchor" href="#73-物理记录"></a> 7.3 物理记录</h4>
<h5 id="731-物理记录格式"><a class="markdownIt-Anchor" href="#731-物理记录格式"></a> 7.3.1 物理记录格式</h5>
<p>物理记录由两部分组成：</p>
<ol>
<li>extra info</li>
<li>实际存储行数据</li>
</ol>
<p>extra info由col offset list和record header组成。实际存储的第一个列的位置称为original offset，物理记录总指向这个位置，不是物理记录实际开始的位置</p>
<p>开始部分col offset list是记录中每个列的偏移量，根据列的顺序逆序。每个offset list除了记录列表的长度，还记录了该列是否为null以及是否包含外部存储属性。</p>
<p>record header的内容帮助innodb读取完整的一行记录，如果需要，并转化为逻辑记录。存放了info_bits信息（记录删除标记，B+树非叶子节点最小记录标记）、记录序号，记录数量、堆中的序号、下一个记录指针等</p>
<p>InnoDB记录在页中，但是页的记录并不是按索引规则排序，页更像一个堆，，其中记录无限，但有堆中序号，记录之间通过指针逻辑串联。堆序号主要是为了实现锁</p>
<p>每个页都有两个虚拟的伪记录，所以heap no（堆号）从2开始</p>
<h5 id="732-大记录格式"><a class="markdownIt-Anchor" href="#732-大记录格式"></a> 7.3.2 大记录格式</h5>
<p>大记录是值某些记录的列不进在当前页，也在其他页（溢出页）。大记录类型有BLOB和TEXT。InnoDB不是把BLOB和TEXT都放溢出页，而是当记录总字节数大于空页的一半时，才放溢出页。对于溢出的列，在列的偏移列表中增加标记。InnoDB的处理方式，当前页值存储溢出列的127个字节，剩下20个字节存储溢出页信息</p>
<p>由于存放于off-page的字节数最大标识最大4个字节，所以BLOB最大4GB</p>
<p>大记录更新时，先把之前的伪删除，然后插入新的记录，回滚时删除新记录，恢复伪删除的数据。</p>
<h5 id="733-伪记录"><a class="markdownIt-Anchor" href="#733-伪记录"></a> 7.3.3 伪记录</h5>
<p>索引页有两个伪记录，分别伪Infimun记录和Supremum记录。用户可以把Infimun当作页中最小记录，Supremun当作最大记录。这里个记录起到了边界的作用。还可以优化锁的性能</p>
<h4 id="74-逻辑记录"><a class="markdownIt-Anchor" href="#74-逻辑记录"></a> 7.4 逻辑记录</h4>
<p>逻辑记录存放于内存，每个dtuple_struct逻辑记录包含多个dfield_struct字段，每个列的数据，大小，类型、列号等</p>
<p>大记录存放在big_rec_struct，每个大记录可能由多个big_rec_field_struct列组成</p>
<h4 id="75-记录比较"><a class="markdownIt-Anchor" href="#75-记录比较"></a> 7.5 记录比较</h4>
<p>B+树索引只能定位到所在的记录页，不能直接定位到具体的查询记录，找到页，还需通过二叉查找算法进行搜索。</p>
<p>记录比较分为逻辑记录比较和物理记录比较。通常都是通过逻辑记录和物理记录比较。对于插入，本身不存在插入的物理记录，要先构建逻辑记录。对于update，delete操作，先通过select定位，这时就转化为逻辑记录</p>
<p>InnoDB使用mtype和prtype分别代表列的类型和列的属性。通过将数据类型转化为mtype和prtype</p>
<p>通过mtype和prtype就可以进行比较</p>
<h4 id="76-行记录版本"><a class="markdownIt-Anchor" href="#76-行记录版本"></a> 7.6 行记录版本</h4>
<p>多版本是指行记录可能一时存在多个版本。记录版本号通过隐藏的事务id列表示，由于事务id自增，所以版本号id也自增</p>
<p>InnoDB通过回滚指针保存前一个版本的undo日志，通过undo日志可以构造出记录的前一个版本，从而实现统一记录的多版本。当没有事务引用这些记录版本，就可以回收这部分undo日志空间。</p>
<p>通过数据结构read_view_struct控制事务应该读取记录的哪个版本</p>
<p>read_view_struct有low_limit_id和up_limit_id保存当前的可见-不可见范围</p>
<p>在事务之前提交的事务，当前事务应当可见，当前事务之后的事务，当前事务不可见。<strong>之间的事务，能否看见取决于创建事务时，事务是否以及提交。对于为提交的事务，不可见。</strong></p>
<p>通过判断当前事务是否可以读取记录当前版本号，若不可以则构建前一个行版本。判断某个事务的版本号是否可见，从小事务开始判断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/7.%E8%AE%B0%E5%BD%95/" data-id="ckmixc6t9000a5cvx8v2368qi" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-6.存储管理" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.041Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="存储管理"><a class="markdownIt-Anchor" href="#存储管理"></a> 存储管理</h3>
<h4 id="62-物理存储"><a class="markdownIt-Anchor" href="#62-物理存储"></a> 6.2 物理存储</h4>
<p>数据库不直接使用操作系统的文件系统，而是在之上封装了一层自己对于存储设备的管理，保证数据库数据库的完整性。</p>
<p>InnoDB最小的存储单位是页，默认16KB</p>
<p>物理磁盘一个扇区512B（固态4KB），文件系统把扇区映射成块，一个块4KB。</p>
<p>为了性能，InnoDB每次申请一个区1MB，64个页，提高空间申请效率和数据存放的顺序性。</p>
<h5 id="621-页"><a class="markdownIt-Anchor" href="#621-页"></a> 6.2.1 页</h5>
<p>页是InnoDB访问的最小I/O单元，物理上连续的64页组成一个区。去除页头尾的46个字节开销，剩下空间原来存储数据。</p>
<p>每个页都有头（38字节）和尾（8字节）</p>
<p>页有页所在表空间的编号和在表空间的偏移量（a,b）。FIL_PAGE_OFFSET长度4个字节，一个表空间可存4GB*16kb 的数据</p>
<p>还有两个指针保存了前后页的偏移量</p>
<p>尾部8个字节和头部一个相同，原来判断页是否完整</p>
<h5 id="622-区"><a class="markdownIt-Anchor" href="#622-区"></a> 6.2.2 区</h5>
<p>区的大小为1MB，区的申请由（space header）空间头部信息进行管理。space header不是一个完整的页，信息保存在页（0，0）（偏移），用于区管理和分配，站112个字节</p>
<p>区分为区和碎片区。区通过链表链接，用于分配给段。碎片区是InnoDB一个特殊区，通过区保存数据前，先将数据保存在32个碎片页中。这样是为了节省空间。碎片区不属于任何段</p>
<p>每次申请区，若空间足够，申请4个，若包含碎片区，申请5个</p>
<p>每个区描述符站40个字节，追踪64个页的使用状态。</p>
<p>头部包含区id，在区链表的位置，区中页的使用情况</p>
<p>InnoDB规定一个页可放256个区描述符，而且偏移都是整数倍</p>
<p>若一个区的页含有区描述符，就称为碎片区</p>
<h5 id="623-段"><a class="markdownIt-Anchor" href="#623-段"></a> 6.2.3 段</h5>
<p>段原来保存特定的对象。表是最常见的对象。</p>
<p>InnoDB中，每个用户表最少两个段，聚簇索引的叶子节点段和非叶子节点段</p>
<p>段根据区的形式组织存储空间</p>
<p>由于有点对象很小，不需要完整的区保存数据，例如undo段，因此给每个段设计了32个碎片页，段的空间首先保存在32个碎片页中，超出后申请空间。碎片页从碎片区申请，碎片区保存在space header中，不能分配给段</p>
<p>InnoDB的设计初衷：创建表开始，随着表的增大，每次从表空间获取一个页，超过32个页后，任务数据很大，每次获取一个区。</p>
<p>segment inode用于保存段的信息，但是位置不固定。一个新的索引就有2个新的段，会有新的segment inode，索引还有一个segment header指向segment inode，每个segment header存放在索引的root页（不一定，可放在单独的页 如insertbuffer）</p>
<h5 id="624-表空间"><a class="markdownIt-Anchor" href="#624-表空间"></a> 6.2.4 表空间</h5>
<p>表空间是一个逻辑概念，由页区段组成。一个表空间可用由多个文件组成。</p>
<h4 id="63-数据结构"><a class="markdownIt-Anchor" href="#63-数据结构"></a> 6.3 数据结构</h4>
<h4 id="64-文件操作"><a class="markdownIt-Anchor" href="#64-文件操作"></a> 6.4 文件操作</h4>
<h5 id="641-异步io和同步io"><a class="markdownIt-Anchor" href="#641-异步io和同步io"></a> 6.4.1 异步I/O和同步I/O</h5>
<p>同步I/O需要阻塞等待其他完成，异步I/O可合并多次I/O。</p>
<p>数据库读操作几乎都是同步I/O，为了提高性能，还支持预读，这部分是异步I/O完成的。对于写操作，特别是脏页刷回磁盘都是异步。</p>
<h4 id="65-异步io"><a class="markdownIt-Anchor" href="#65-异步io"></a> 6.5 异步I/O</h4>
<h5 id="651-异步io数据结构"><a class="markdownIt-Anchor" href="#651-异步io数据结构"></a> 6.5.1 异步I/O数据结构</h5>
<p>由4个异步I/O线程。分别处理异步读I/O，异步写I/O，插入缓存I/O，重做日志I/O</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/6.%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" data-id="ckmixc6t700095cvxgfh92co3" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-5.mini-transaction" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/5.mini-transaction/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.039Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="mini-transaction"><a class="markdownIt-Anchor" href="#mini-transaction"></a> mini-transaction</h3>
<h4 id="52-mini-transaction"><a class="markdownIt-Anchor" href="#52-mini-transaction"></a> 5.2 mini-transaction</h4>
<h5 id="521-基本概念"><a class="markdownIt-Anchor" href="#521-基本概念"></a> 5.2.1 基本概念</h5>
<p>mini-transaction模块，是用来实现InnoDB存储引擎物理逻辑日志的写入，通过mini-transaction保证并发事务操作下数据库异常时页数据的一致性。</p>
<p>mini-transaction仅仅用来保证页的一致性，而事务可能需要保证多个页操作数据的一致性和持久性。或者说，事务的一致性和持久性需要通过mini-transaction实现</p>
<p>当用户修改页时，通过类似的mini-transaction形式：</p>
<ol>
<li>lock专享的页</li>
<li>修改页</li>
<li>生成undo log和redo log</li>
<li>unlock页</li>
</ol>
<p>为了保证页的一致性，需要遵循：</p>
<ol>
<li>FIX Rules</li>
<li>Write-Ahead Log</li>
<li>Force-log-at-commit</li>
</ol>
<h5 id="522-fix-rules"><a class="markdownIt-Anchor" href="#522-fix-rules"></a> 5.2.2 FIX Rules</h5>
<p>当数据库访问或修改一个页时，需要持有该页的latch，保证并发的数据一致性。将这个latch称为fixing the page。获得latch后，称这个页已经fixed，</p>
<p>规则如下：</p>
<ol>
<li>修改一个页需要获得x-latch</li>
<li>访问一个页获得x-latch或s-latch</li>
<li>持有latch到修改或访问完数据</li>
</ol>
<p>如果要一次性修改多个页，需要持有多个页的latch，操作完成再释放</p>
<p>每个页struct的lock变量实现对页latch的操作。一个事务读取该页，变量就+1.当LRU替换时，必须保证为0才能替换。</p>
<p>InnoDB对FIX Rules进行了调整，若操作的页是B+树的非叶子节点，非页节点通过B+树的索引的latch维护，因此操作这些页不需要持有页的latch。</p>
<p>因此，再InnoDB判断页是否被fix的标准是lock变量是否为0</p>
<h5 id="523-write-ahead-log"><a class="markdownIt-Anchor" href="#523-write-ahead-log"></a> 5.2.3 Write-Ahead-Log</h5>
<p>WAL要求一个页操作再写入到持久存储设备时，首先必须将内存中的日志写入到持久存储</p>
<ol>
<li>每个页要有一个LSN</li>
<li>每次页的修改操作需要维护该LSN</li>
<li>当一个页刷新到持久存储设备时，要求将所有内存小于该页LSN的日志都持久化</li>
<li>当日志持久化后，将内存中的页持久化</li>
<li>页持久化时，需要fiexd保证页的一致性</li>
</ol>
<h5 id="524-force-log-at-commit"><a class="markdownIt-Anchor" href="#524-force-log-at-commit"></a> 5.2.4 Force-log-at-commit</h5>
<p>仅仅靠WAL无法保证事务的持久性，还需要force-log-at-commit</p>
<p>当事务提交时，所有mini-transaction产生的日志都必须刷新到持久存储设备</p>
<p>innodb_flush_log _at_trx_commit=0表示关闭</p>
<h4 id="53-具体实现"><a class="markdownIt-Anchor" href="#53-具体实现"></a> 5.3 具体实现</h4>
<h5 id="531-数据结构"><a class="markdownIt-Anchor" href="#531-数据结构"></a> 5.3.1 数据结构</h5>
<p>mtr_struct实现mini-transaction</p>
<h5 id="532-物理逻辑日志的实现"><a class="markdownIt-Anchor" href="#532-物理逻辑日志的实现"></a> 5.3.2 物理逻辑日志的实现</h5>
<p>InnoDB的redo log是物理逻辑的，所以需要记录每种重做日志的”逻辑“（每种重做日志的类型）</p>
<p>恢复时，根据类型对对应的也进行”逻辑“恢复</p>
<p>重做日志的开始信息由重做日志类型type、表空间ID space、页在表空间的偏移组成offset</p>
<p>type占1个字节，space和offset都通过压缩的方式存储。body体的根据日志类型不同内容不同</p>
<p>例如插入记录：记录的时插入记录的前一个记录的位置和插入记录与前一个记录的差异，所以如果一个页corrupt，无法恢复。</p>
<p>如果一个mini-transaction涉及多个页的变化，会有多个页的redo-log，会在结束时加入一个结束标志表示记录了多个页的日志</p>
<h5 id="533-mini-transaction的使用"><a class="markdownIt-Anchor" href="#533-mini-transaction的使用"></a> 5.3.3 mini-transaction的使用</h5>
<ol>
<li>每个mini-transaction拥有自己的redo log entity</li>
<li>mini-transaction持有mutex互斥量写入redo log buffer</li>
<li>redo log buffer进行缓存写，写入操作系统内存，然后写入磁盘</li>
<li>由于redo log进行fsync时已经释放了mutex，所以可以进行组提交，当一个事务进行fsync时，其他事务可以获得mutex对象，将重做日志写入重做日志缓存，下一次事务提交时，可以将多个事务的重做日志一次性写入重做日志文件</li>
</ol>
<p>当一个事务没有对页修改也要使用mini-transaction，访问数据要符合FIX Rules规则，而mini-transaction包含次功能。当提交时，仅仅对页进行unfix操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/5.mini-transaction/" data-id="ckmixc6t500065cvxe4jyb6u6" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-4.重做日志" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/21/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/" class="article-date">
  <time class="post-time" datetime="2021-03-21T08:54:35.036Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="重做日志"><a class="markdownIt-Anchor" href="#重做日志"></a> 重做日志</h3>
<h4 id="42-相关概述"><a class="markdownIt-Anchor" href="#42-相关概述"></a> 4.2 相关概述</h4>
<h5 id="421-简介"><a class="markdownIt-Anchor" href="#421-简介"></a> 4.2.1 简介</h5>
<p>redo log用来实现事务的持久性，ACID的D。由两部分组成，一是内存中的重做日志换成(redo log buffer)，易丢失，二是重做日志文件(redo log file)，持久</p>
<p>InnoDB是事务存储引擎，通过force log at commit实现日志持久化。当事务提交时，先将事务日志写入重做日志文件持久化，完成后再commit。</p>
<p>InnoDB日志由两部分组成，redo log和undo log。redo log保证事务的持久性。undo log帮助事务回滚以及MVCC功能。redo log是顺序写的，数据库允许时不需要对redo log进行读操作。undo log随机读/写。</p>
<p>为了确保每次日志都写入重做日志文件，每次将重做日志缓存写入重做日志文件后，InnoDB需要调用一个fsync操作（同步内存到磁盘）。使用fsync效率取决于磁盘性能。磁盘性能决定了事务的提交性能。</p>
<p>InnoDB允许用户设置不强制fsync，日志定时从内存写入磁盘。可以提高数据库性能。可能会丢失最后一段时间事务</p>
<p>innodb_flush_log_at_trx_commit控制策略。1强制提交，0定时提交。master thread（现在可能是其他线程）每秒进行一次redo log的fsync操作。设置未0，不符合事务的D(Durablity)特性。后续版本设为2，将redo log写入操作系统缓存，数据库宕机，操作系统不宕机，不会丢失事务。</p>
<p>MySQL还有一个二进制日志文件（bin-log），用来进行point-in-time（PIT）恢复以及主从复制。表明与redo log很像，其实本质不同。</p>
<p>redo log是InnoDB存储引擎产生，bin log是MySQL数据库上层产生，不仅仅针对InnoDB引擎。</p>
<p>两种日志内容形式不同。bin log是逻辑日志，记录对应的SQL语句（三种形式）。redo log是物理日志，记录对每个页的修改。</p>
<p>两种日志写入磁盘时间不同。bin log在事务完成后一次写入，redo log在事务进行中不断写日，表现为日志并不是随事务提交而顺序写入。</p>
<p>bin log  t1-t4-t3-t2… 一个事务一个日志（一个日志多个log event)</p>
<p>redo log t1-t2-t1-<em>t2… 一个事务多个日志，多个事务并发写入（随机写），</em> *表示提交</p>
<h5 id="422-物理逻辑日志"><a class="markdownIt-Anchor" href="#422-物理逻辑日志"></a> 4.2.2 物理逻辑日志</h5>
<p>redo log类型：</p>
<ol>
<li>物理日志：保存一个页中发生改变的字节，保存页中发生变化的字节，数据结构包括页位置，偏移，长度，旧值，新值。该日志幂等（执行多次仍一样）。产生的日志量比较大。</li>
<li>逻辑日志：记录对表的操作&lt;insert op,table name, record value&gt;，日志尺寸小，undo 操作需要对日志操作逆操作。恢复时无法保证数据一致性。插入时宕机，若还有其他索引，回滚会很困难。</li>
<li>物理逻辑日志：结合了物理日志和逻辑日志。对页是物理的，对页内操作是逻辑的。</li>
</ol>
<h5 id="423-lsn"><a class="markdownIt-Anchor" href="#423-lsn"></a> 4.2.3 LSN</h5>
<p>LSN是log sequence number缩写，代表日志序列号。占用8个字节</p>
<p>LSN单调递增，代表每个redo log的编号。初始值由LOG_START_LSN定义</p>
<p>LSN在多个对象中，含义各不相同。</p>
<p>在redo log中，表示事务写入redo log的字节量。因为redo log先写缓存，索引存在缓存的LSN和日志的LSN两部分</p>
<p>在每个页中，记录在页的头部，有个FIL_PAGE_LSN，记录页的LSN，表示该页罪和刷新时LSN大小。redo log记录的是页的日志，页的LSN判断页是否需要进行恢复。</p>
<p>检测到也通过LSN保存，表示页已经刷新到磁盘的LSN位置，重启时只需要从监测点开始恢复，检测到LSN和redo log LSN相同，不需要恢复。</p>
<h5 id="424-检查点"><a class="markdownIt-Anchor" href="#424-检查点"></a> 4.2.4 检查点</h5>
<p>InnoDB为了实现事务持久性，使用了write ahead log(WAL)策略，当事务提交时，先写入redo log，实际数据页刷到磁盘由检测到负责。</p>
<p>虽然日志已经写入到磁盘，但是buffer pool的页还没有刷到磁盘。</p>
<p>检测点就是将缓冲池的页刷新到磁盘。</p>
<p>检测点的作用就是缩短数据库宕机时到数据库恢复的时间。</p>
<p>InnoDB存在两种检测点：</p>
<ol>
<li>sharp checkpoint：将脏页全部刷到磁盘，加速宕机恢复，但是刷页时不能进行DML操作</li>
<li>fuzzy checkpoint：脏页慢慢刷到磁盘，提高了系统可用性。但是得将页按第一次修改的LSN排序</li>
</ol>
<h5 id="425-归档日志"><a class="markdownIt-Anchor" href="#425-归档日志"></a> 4.2.5 归档日志</h5>
<p>InnoDB中，redo log文件大小固定，如果3个redo log，大小1G，一共就3G。循环使用。</p>
<p>为了保存之前的redo log，设计了归档日志。</p>
<h5 id="426-恢复"><a class="markdownIt-Anchor" href="#426-恢复"></a> 4.2.6 恢复</h5>
<p>InnoDB启动时，不管是否正常改变，都试图恢复。redo log是物理日志，恢复较快。</p>
<p>InnoDB对恢复进行了优化，顺序读取和并行应用redo log。</p>
<h4 id="43-物理存储结构"><a class="markdownIt-Anchor" href="#43-物理存储结构"></a> 4.3 物理存储结构</h4>
<h5 id="431-redo-log物理结构"><a class="markdownIt-Anchor" href="#431-redo-log物理结构"></a> 4.3.1 redo log物理结构</h5>
<p>InnoDB的redo log由以下几个部分组成</p>
<ol>
<li>重做日志缓存(redo log buffer)：由innodb_log_buffer_size控制，默认1MB</li>
<li>重做日志组(redo log group)：多个组的内容一致，保证可用性，但是只能由一个组，不能启用镜像</li>
<li>每个重做日志组包含多个重做日志文件(redo log file)：可能由多个同样大小的文件组成，默认前缀ib_logfile，参数innodb_log_group_home_dir指定日志路径。innodb_log_files_in_group指定组文件数量。innodb_log_file_size指定每个redo log大小。默认5MB。总redo log大小必须小于4GB（不能等于）</li>
<li>归档重做日志文件(archive redo log)：对重做日志组1进行归档。innodb_log_archive开启归档，默认关闭，默认路径和日志路径相同，前缀ib_arch_log_</li>
</ol>
<h5 id="432-redo-log-块"><a class="markdownIt-Anchor" href="#432-redo-log-块"></a> 4.3.2 redo log 块</h5>
<p>redo log块以512字节存储，意味着redo log buffer，redo log file和archive 都是以块的方式保存的。</p>
<p>因为redo log块大小和扇区大小一致，可以保证写入的原子性，不需要doublewrite</p>
<p>redo log块除了日志本身，还有日志快头（12字节）和日志快尾（8字节）。</p>
<p>log block header包含：</p>
<p>LOG_BLOCK_HDR_NO：log buffer类似数组，这个值就是索引，4个字节，最高位判断是不是flush bit，所以最大2GB</p>
<p>LOG_BLOCK_HDR_DATA_LEN：2个字节，日志快占用的大小，写满时未0x200，表示512个字节</p>
<p>LOG_BLOCK_FIRST_REC_GROUP：2个字节，当前块第一个日志的所在偏移量</p>
<p>LOG_BLOCK_CHECK_POINT_NO：4个字节，日志块最后被写入时log_sys-&gt;next_checkpoint_no的低4个字节</p>
<p>log block tailer：只包含LOG_BLOCK_HDR_NO和头部一样</p>
<h5 id="433-重做日志组和文件"><a class="markdownIt-Anchor" href="#433-重做日志组和文件"></a> 4.3.3 重做日志组和文件</h5>
<p>log buffer刷盘规则：</p>
<ol>
<li>事务提交时</li>
<li>写入检查点值时</li>
<li>log buffer超过以使用空间的阈值时</li>
</ol>
<p>log block是通过appen追加的，一个写满写下一个，循环使用(round-robin)</p>
<p>虽然是在文件最后append，但不都是顺序写。redo log file还有2KB其他信息。保存了4个512字节大小的块</p>
<p>log file header  512字节：</p>
<p>​	log_group_id 4个字节：重做日志组号</p>
<p>​	log_file_start_lsn 8个字节：表示每个重做日志文件的第一个日志的LSN</p>
<p>checkpoint1  512字节：实际占用296字节</p>
<p>​	log_checkpoint_lsn：两个checkpoint块交替写更新checkpoint的值</p>
<p>​	log_checkpoint_offset：多个redo log file视为一个大数组，这是对应的LSN所在的offset</p>
<p>​	log_checkpoint_array：记录的是(fileno,offset)对，共32对(32*(4+4))=256字节，表示每个重做日志组的归档文件号，最多32个日志组。</p>
<p>空	512K</p>
<p>checkpoint2 512K字节</p>
<p>这些信息只在每个组的第一个文件保存，后面的文件也占有这些空间，但不存内容。</p>
<p>因为这些信息，除了log block写入，还更新这些信息。这些信息对于redo log恢复至关重要。</p>
<h4 id="44-数据结构"><a class="markdownIt-Anchor" href="#44-数据结构"></a> 4.4 数据结构</h4>
<h5 id="441-log_group_struct"><a class="markdownIt-Anchor" href="#441-log_group_struct"></a> 4.4.1 log_group_struct</h5>
<h5 id="442-log_struct"><a class="markdownIt-Anchor" href="#442-log_struct"></a> 4.4.2 log_struct</h5>
<p>表示重做日志缓存，由log_init()初始化，控制着重做日志缓存的写入，重做日志文件写入，归档重做日志的写入，在线备份等。</p>
<p>遍历buf_free表示当前重做日志缓存写入的开始位置，当大于max_buf_free时，强制进行一次重做日志文件写入。初始化时，max_buf_free设为redo log buffer的一半。</p>
<p>系统又一个控制全局的log_struct对象log_sys，实现对重做日志的操作。并发控制由数据结构log_sys中的mutex保护。保护所有的重做日志。所有重做日志的I/O是异步的，可以提前释放mutex，写入都是先写入缓存，再进行fsync，进行fsync时解法mutex保护。</p>
<h4 id="45-组提交"><a class="markdownIt-Anchor" href="#45-组提交"></a> 4.5 组提交</h4>
<p>一个事务提交一次需要进行一次fsync，为了提高性能，允许一组事务进行提交，组提交。</p>
<p>当重做日志缓冲刷新到磁盘时，先拷贝最后一个日志块，允许之后的事务写到该块，实现组提交。</p>
<p>组提交时重做日志的写入是缓存写（经过操作系统内核的page cache），没有使用O_DIRECT（之间磁盘IO）</p>
<h4 id="46-恢复"><a class="markdownIt-Anchor" href="#46-恢复"></a> 4.6 恢复</h4>
<h5 id="461-数据结构"><a class="markdownIt-Anchor" href="#461-数据结构"></a> 4.6.1 数据结构</h5>
<p>recv_sys_struct用来管理重做日志恢复。</p>
<p>其中add_hash是一个哈希表，每个bucket存放着recv_addr_t数据结构。根据(space,page_no)哈希，相同的放入一个bucket。recv_addr_t存放对应(space,page_no)页的重做日志recv_t，一个页可能由多个重做日志，通过链表将recv_t相连。每个recv_t记录了重做日志的类型，长度，开始LSN，结束LSN，已经重做日志body。body由recv_data_t定义（16KB），对大于该长度的重做日志，需要使用next指针进行链接</p>
<p>由于每个重做日志大小不同，采用动态内存分配奇数。</p>
<h5 id="462-重做日志恢复"><a class="markdownIt-Anchor" href="#462-重做日志恢复"></a> 4.6.2 重做日志恢复</h5>
<p>InnoDB启动时，不管是否正常关闭，都尝试恢复。</p>
<p>InnoDB表空间第一个页记录了数据库关闭时最后刷新页的LSN，若未正常关闭，该值和redo log的checkpoint值不同，就需要恢复</p>
<p>恢复数据时，通过小批量读取重做日志文件的log block到log_sys的buf中（64KB= 128*512k)，然后根据对应的(space,offset)插入recv_sys哈希表（addr_hash)，然后进行恢复。若保存的页过多，会强制进行恢复。</p>
<ol>
<li>分析重做日志</li>
<li>重做日志加入hash表</li>
<li>将hash表重做日志应用到页上：判断页的LSN，当大于待恢复重做日志的LSN，表示页已经写入磁盘或恢复过</li>
</ol>
<p>异步恢复：扫描一个页相邻的32个页，如果待恢复而且不在内存，就记录。然后异步读取页进行恢复。这样可以并行恢复页</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/21/4.%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97/" data-id="ckmixc6t700085cvx2dkg4mas" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">John Doe</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>45</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags"><div><strong>0</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/slorui" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2020 - 2021 John Doe<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>